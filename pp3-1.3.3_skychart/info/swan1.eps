%!PS-Adobe-2.0
%%Creator: dvips(k) 5.993 Copyright 2013 Radical Eye Software
%%Title: swan1.dvi
%%CreationDate: Mon Jun  8 11:28:23 2015
%%Pages: 1
%%PageOrder: Ascend
%%BoundingBox: 0 0 199 100
%%DocumentFonts: NimbusSanL-Regu StandardSymL
%%EndComments
%DVIPSWebPage: (www.radicaleye.com)
%DVIPSCommandLine: dvips -o swan1.eps swan1
%DVIPSParameters: dpi=600
%DVIPSSource:  TeX output 2015.06.08:1128
%%BeginProcSet: tex.pro 0 0
%!
/TeXDict 300 dict def TeXDict begin/N{def}def/B{bind def}N/S{exch}N/X{S
N}B/A{dup}B/TR{translate}N/isls false N/vsize 11 72 mul N/hsize 8.5 72
mul N/landplus90{false}def/@rigin{isls{[0 landplus90{1 -1}{-1 1}ifelse 0
0 0]concat}if 72 Resolution div 72 VResolution div neg scale isls{
landplus90{VResolution 72 div vsize mul 0 exch}{Resolution -72 div hsize
mul 0}ifelse TR}if Resolution VResolution vsize -72 div 1 add mul TR[
matrix currentmatrix{A A round sub abs 0.00001 lt{round}if}forall round
exch round exch]setmatrix}N/@landscape{/isls true N}B/@manualfeed{
statusdict/manualfeed true put}B/@copies{/#copies X}B/FMat[1 0 0 -1 0 0]
N/FBB[0 0 0 0]N/nn 0 N/IEn 0 N/ctr 0 N/df-tail{/nn 8 dict N nn begin
/FontType 3 N/FontMatrix fntrx N/FontBBox FBB N string/base X array
/BitMaps X/BuildChar{CharBuilder}N/Encoding IEn N end A{/foo setfont}2
array copy cvx N load 0 nn put/ctr 0 N[}B/sf 0 N/df{/sf 1 N/fntrx FMat N
df-tail}B/dfs{div/sf X/fntrx[sf 0 0 sf neg 0 0]N df-tail}B/E{pop nn A
definefont setfont}B/Cw{Cd A length 5 sub get}B/Ch{Cd A length 4 sub get
}B/Cx{128 Cd A length 3 sub get sub}B/Cy{Cd A length 2 sub get 127 sub}
B/Cdx{Cd A length 1 sub get}B/Ci{Cd A type/stringtype ne{ctr get/ctr ctr
1 add N}if}B/CharBuilder{save 3 1 roll S A/base get 2 index get S
/BitMaps get S get/Cd X pop/ctr 0 N Cdx 0 Cx Cy Ch sub Cx Cw add Cy
setcachedevice Cw Ch true[1 0 0 -1 -.1 Cx sub Cy .1 sub]{Ci}imagemask
restore}B/D{/cc X A type/stringtype ne{]}if nn/base get cc ctr put nn
/BitMaps get S ctr S sf 1 ne{A A length 1 sub A 2 index S get sf div put
}if put/ctr ctr 1 add N}B/I{cc 1 add D}B/bop{userdict/bop-hook known{
bop-hook}if/SI save N @rigin 0 0 moveto/V matrix currentmatrix A 1 get A
mul exch 0 get A mul add .99 lt{/QV}{/RV}ifelse load def pop pop}N/eop{
SI restore userdict/eop-hook known{eop-hook}if showpage}N/@start{
userdict/start-hook known{start-hook}if pop/VResolution X/Resolution X
1000 div/DVImag X/IEn 256 array N 2 string 0 1 255{IEn S A 360 add 36 4
index cvrs cvn put}for pop 65781.76 div/vsize X 65781.76 div/hsize X}N
/dir 0 def/dyy{/dir 0 def}B/dyt{/dir 1 def}B/dty{/dir 2 def}B/dtt{/dir 3
def}B/p{dir 2 eq{-90 rotate show 90 rotate}{dir 3 eq{-90 rotate show 90
rotate}{show}ifelse}ifelse}N/RMat[1 0 0 -1 0 0]N/BDot 260 string N/Rx 0
N/Ry 0 N/V{}B/RV/v{/Ry X/Rx X V}B statusdict begin/product where{pop
false[(Display)(NeXT)(LaserWriter 16/600)]{A length product length le{A
length product exch 0 exch getinterval eq{pop true exit}if}{pop}ifelse}
forall}{false}ifelse end{{gsave TR -.1 .1 TR 1 1 scale Rx Ry false RMat{
BDot}imagemask grestore}}{{gsave TR -.1 .1 TR Rx Ry scale 1 1 false RMat
{BDot}imagemask grestore}}ifelse B/QV{gsave newpath transform round exch
round exch itransform moveto Rx 0 rlineto 0 Ry neg rlineto Rx neg 0
rlineto fill grestore}B/a{moveto}B/delta 0 N/tail{A/delta X 0 rmoveto}B
/M{S p delta add tail}B/b{S p tail}B/c{-4 M}B/d{-3 M}B/e{-2 M}B/f{-1 M}
B/g{0 M}B/h{1 M}B/i{2 M}B/j{3 M}B/k{4 M}B/w{0 rmoveto}B/l{p -4 w}B/m{p
-3 w}B/n{p -2 w}B/o{p -1 w}B/q{p 1 w}B/r{p 2 w}B/s{p 3 w}B/t{p 4 w}B/x{
0 S rmoveto}B/y{3 2 roll p a}B/bos{/SS save N}B/eos{SS restore}B end

%%EndProcSet
%%BeginProcSet: pstricks.pro 0 0
% $Id: pstricks.pro 856 2013-12-09 10:34:40Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 1.21, 2013/11/28
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
% Define the follwing gs-functions if not known, eg when using distiller
%
systemdict /.setopacityalpha known not {/.setopacityalpha { pop } def } if
systemdict /.setblendmode known not {/.setblendmode { pop } def } if
systemdict /.setshapealpha known not {/.setshapealpha { pop } def } if
%
/tx@Dict 200 dict def 				% the main PSTricks dictionary
tx@Dict begin
/ADict 25 dict def				% The arrow dictionary
/CM { matrix currentmatrix } bind def
/SLW /setlinewidth load def
/CLW /currentlinewidth load def
/CP /currentpoint load def
/ED { exch def } bind def
/L /lineto load def
/T /translate load def
/TMatrix { } def
/RAngle { 0 } def
/Sqrt { dup 0 lt { pop 0 } { sqrt } ifelse } def  % return 0 for negative arguments 
/Atan { /atan load stopped { pop pop 0 } if } def % return 0 if atan not known
/ATAN1 {neg -1 atan 180 sub } def		% atan(x) (only one parameter)
/Div { dup 0 eq { pop } { div } ifelse } def  	% control the division
/tan { dup cos abs 1.e-10 lt 
  { pop 1.e10 } 				% return 1.e10 as infinit
  { dup sin exch cos div } ifelse 		% default sin/cos
} def
/Tan { dup sin exch cos Div } def 		% sin(x)/cos(x) x in degrees
/Acos {dup dup mul neg 1 add dup 0 lt {		% arc cos, returns 0 when negative root
  pop pop 0 }{ sqrt exch atan} ifelse } def
/Acos2 { 2 dict begin 
  /x ED /y ED
  y abs 1.0e-20 lt { 1.0e30 } if
  x y div 
  dup dup mul neg 1 add dup 0 lt {		% arc cos needs two values x,y
  pop pop 0 }{ sqrt exch atan} ifelse 
  y 0 lt { 180 add } if
} def
/NET { neg exch neg exch T } def	      	% change coordinate system to the negative one		
/Pyth { dup mul exch dup mul add sqrt } def   	% Pythagoras, expects 2 parameter
/Pyth2 {					% Pythagoras, xA yA xB yB
  3 -1 roll 		% xA xB yB yA
  sub			% xA xB yB-yA
  3 1 roll 		% yB-yA xA xB
  sub			% yB-yA xA-xB
  Pyth } def
/PtoC { 2 copy cos mul 3 1 roll sin mul } def 	% Polar to Cartesian
%/Rand { rand 4294967295 div } def		% a real random number
/Rand { rand 2147483447 div } def		% a real random number between 0 and 1
%----------------- hv added 20050516 ---------------
/PiDiv2 1.57079632680 def
/Pi 3.14159265359 def 
/TwoPi 6.28318530718 def
/Euler 2.71828182846 def 
%/e Euler bind def
%
/RadtoDeg { 180 mul Pi div } bind def 		% convert from radian to degrees
/DegtoRad { Pi mul 180 div } bind def 		% viceversa
%
/startGlobal { true setglobal globaldict begin } bind def
/endGlobal { end false setglobal } bind def
/pssetRGBcolor /setrgbcolor load def
/pssetCMYKcolor /setcmykcolor load def
/pssetGraycolor /setgray load def
%
%----------------- hv end---------------------------
/PathLength@ { /z z y y1 sub x x1 sub Pyth add def /y1 y def /x1 x def } def
%
/PathLength { 
  flattenpath /z 0 def 
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def }
  { /y ED /x ED PathLength@ } 
  {} 
  { /y y2 def /x x2 def PathLength@ }
  /pathforall load stopped { pop pop pop pop } if 
  z 
} def
%
/STP { .996264 dup scale } def			% BP/PT scaling
/STV { SDict begin normalscale end STP  } def	% 
%
/DashLine {
    dup 0 gt
    { /a .5 def PathLength exch div }
    { pop /a 1 def PathLength } ifelse
    /b ED % pattern should fit evenly in b
    dup /X ED % pattern array
    0 get /y ED % length of first black segment
    /z 0 X {add} forall def % length of the full pattern
    %% Computation of the scaling factor as described by van Zandt:
    b a .5 sub 2 mul y mul sub z Div round
    z mul a .5 sub 2 mul y mul add b exch Div
    %%%% scaling factor on stack.
    /z ED %% now, z is the scaling factor
    false % for the length test below
    X { z mul } forall X astore %% modification TN 04-08-07
    %%% Checking whether at least one dash in X has positive length:
    {0 gt or} forall
    { X 1 a sub y mul }
    { [ 1 0 ] 0 }
    ifelse
    setdash stroke
} def
%
/DotLine { 
  /b PathLength def 
  /a ED /z ED /y CLW def 
  /z y z add def 
  a 0 gt { 
    /b b a div def 
  }{ 
    a 0 eq { 
      /b b y sub def 
    }{ a -3 eq { 
      /b b y add def } if 
    } ifelse 
  } ifelse 
  [ 0 b b z Div round Div dup 0 le { pop 1 } if ] 
  a 0 gt { 0 }{ y 2 div a -2 gt { neg }if } ifelse 
  setdash 1 setlinecap stroke 
} def
%
/SymbolLine {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 div cvi /n ED     				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    %% for negative SymStep we calculate the distance 
    SymStep 0 lt 
      { %XYLength SymStep div abs cvi 
        /nSym SymStep abs cvi def } 
      { /nSym XYLength SymStep div cvi def }
    ifelse
    0.5 setflat
    /Shift Symbol stringwidth pop 2 div def 
    /deltaX XLength nSym div def
    /deltaY YLength nSym div def
    curveticks 
      { XA YA moveto }
      { XA Shift sub YA Shift sub moveto }
    ifelse 
    nSym { 
      gsave 
      curveticks 
        { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
          currentpoint translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
          Symbol show 
        }
      ifelse 
      grestore 
      deltaX deltaY rmoveto
    } repeat
    /YA YB def /XA XB def
  } repeat 
  curveticks 
    { XA YA moveto }
    { XA Shift sub YA Shift sub moveto }
  ifelse 
  gsave 
  curveticks 
    { PAngle 180 sub CorrAngle sub tickAngle add /rotAngle ED  
      XA YA translate rotAngle rotate 
      0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
      SymbolLinewidth setlinewidth stroke
    }
    { 
      rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
    }
  ifelse 
  grestore
  pop 				% delete the mark symbol
} def
%
/LineFill { % hv ------------ patch 7 -------------
  gsave 
  abs /hatchWidthInc ED
  abs /hatchSepInc ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  2 setlinecap 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  x2 x1 sub 1 add { 
    x1 a mul y1 moveto 0 y2 rlineto stroke 
    /x1 x1 1 add 
      hatchWidthInc 0 gt { CLW add } if 
    def 
    hatchSepInc 0 gt hatchWidthInc 0 gt or { 
      /a a hatchSepInc add def
      CLW hatchWidthInc add SLW 
    } if
  } repeat 
  grestore 
  pop pop } def
%
/DotFill {%	 on stack: dot radius
  /dotRadius ED
  abs CLW add /a ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform 
  pathbbox % llx lly urx ury of smallest bounding box
  /y2 ED /x2 ED /y1 ED /x1 ED 
  y2 y1 sub a div 2 add cvi /Ny ED
  x2 x1 sub a div 2 add cvi /Nx ED
  clipType   % must be defined in pstricks.tex: clip -- eoclip 
  newpath 
  /yA y1 dotRadius add CLW add def
  /xA0 x1 dotRadius add CLW add def
  Ny {
     /xA xA0 def
     Nx { 
       newpath 
       xA yA dotRadius 0 360 arc 
       SolidDot { gsave fill grestore } if 
       stroke
       xA a add /xA ED
     } repeat
     yA a add /yA ED
  } repeat
  grestore
} def
%
/PenroseFill {%	 on stack: scaling factor
  /Scale ED
%  1 exch div round /penroseFactor ED 
%  a 0 dtransform round exch round exch
%  2 copy idtransform 
%  exch Atan rotate 
%  idtransform pop /a ED 
%  .25 .25 itransform pathbbox 
%  /y2 ED 
%  a Div ceiling cvi /x2 ED /y1 ED 
%  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
gsave
  220 150 translate
  Scale dup scale
  systemdict /setstrokeadjust known { true setstrokeadjust } if 
  /I/S/L/W/G/+/Z/F/E/D[/def/exch/for{E D}/add{s E get mul}
 { Z -36.2001 1 33 }{25 E S rlineto}{/q Z dup q G E q 1 + G}{Z 2 2}]{cvx def}forall
  [0 72 1008 {dup sin E cos }F ]1 setlinejoin/s W{/a W{/b I 10{/i I 4{/m I moveto
  i m +/j I 10{/l Z b m l + G a l G sub s m get div .2 + floor .3 + 25
  mul j l + S rmoveto}F i L j L stroke }F}F}F}F 
  grestore 
%  pop pop 
} def
%
/PenroseFillA {%  on stack: scaling factor, border color, kite color, dart color
  /Scale ED
  Scale dup scale
  /border_colour ED 
  /kite_colour ED 
  /dart_colour ED
  clip 
  newpath 
  gsave
  100 100 translate
  6 
  Scale 1 lt { 1 Scale dup add div mul cvi } if %%%%   Number of iterations
  10					%%%%   Long side length in millimeters
  /border_width { L 0.06 mul }def		%%%%   Choose the scalefactor for the borders
  /L exch 25.4 div 72 mul def		%%%%   Conversion: mm -> inches -> points
  /f{-1 5 sqrt add 2 div}bind def		%%%%   The reciprocal of the golden ratio
  /l{L f mul}bind def			%%%%   Short side length l = L*f
  /Ll{L l add}bind def			%%%%   Ll =  L + l
  /c{36 cos L mul}bind def		%%%%   c  =  L*cos(36)
  /s{36 sin L mul}bind def		%%%%   s  =  L*sin(36)
  /draw_tile { 0 0 moveto c s lineto 0 lineto gsave closepath gsave fill grestore
	     0 setlinewidth stroke grestore border_colour stroke } bind def
  /half_kite { dup dup 0 gt{ 1 sub gsave f f neg scale -36 rotate half_dart
			   Ll 0 translate 144 rotate kite grestore }
	      		 { kite_colour L draw_tile }ifelse
	     pop } bind def
  /half_dart { dup dup 0 gt{ 1 sub gsave f f scale half_kite
			   -144 rotate Ll neg 0 translate half_dart grestore }
	      		 { dart_colour l draw_tile }ifelse
  	     pop } bind def
  /kite{ gsave half_kite 1 -1 scale half_kite grestore }bind def
  border_width setlinewidth  1 setlinejoin  1 setlinecap
%  450 0 translate  
  dup f exch neg exp dup scale
  5 {kite 72 rotate } repeat stroke 
  grestore
} def
%
%
/TruchetFill { %	 on stack: scaling factor
  10 dict begin
  dup dup scale
  1 exch div round /penroseFactor ED 
  a 0 dtransform round exch round exch
  2 copy idtransform 
  exch Atan rotate 
  idtransform pop /a ED 
  .25 .25 itransform pathbbox 
  /y2 ED 
  a Div ceiling cvi /x2 ED /y1 ED 
  a Div cvi /x1 ED /y2 y2 y1 sub def 
  clip 
  newpath 
  systemdict
  /setstrokeadjust known { true setstrokeadjust } if 
  /ma a neg def
  /ha a 2 div def 
  /mha ha neg def
  /tile { 
    rand dup 2 idiv 2 mul eq { 90 rotate } if
    mha mha moveto ha mha lineto
    ha ha lineto mha ha lineto
%    closepath .1 setlinewidth stroke
    contents
  } def
  /contents{ 
    0 ha moveto ha 0 lineto
    0 mha moveto mha 0 lineto
%    1 setlinewidth stroke
  } def
  /dotiling {
    f ma mul a f a mul { 
      /i exch def
      f ma mul a f a mul { 
        /j exch def
        gsave i j translate
        tile stroke grestore
      } for
    } for
  } def
%
  /f 3 def 
  5 srand dotiling 
  end % local user dict
} def
%
/BeginArrow { 
  ADict begin 			% hold it local, for end see EndArrow
  /@mtrx CM def 
  gsave 
  2 copy T 
  2 index sub neg exch 
  3 index sub exch Atan 
  rotate newpath 
} def
%
/EndArrow { @mtrx setmatrix CP grestore end } def % end the ADict
%
/Arrow { 
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /a ED 
  { 0 h T 1 -1 scale } if 
  w neg h moveto 
  0 0 L w h L w neg a neg rlineto 
  gsave fill grestore 
} def
%
/ArrowD { % the sides are drawn as curves (hv 20071211)
  CLW mul add dup 
  2 div /w ED 
  mul dup /h ED 
  mul /Inset ED 
  { 0 h T 1 -1 scale } if % changes the direction
% we use y=w/h^2 * x^2 as equation for the control points
% for the coordinates the arrow is seen from top to bottom
% the bottom (tip) is (0;0)
  w neg h moveto % lower left of >
  w 9 div 4 mul neg h 3 div 2 mul
  w 9 div neg       h 3 div  
  0 0 curveto    % tip of >
  w 9 div        h 3 div  
  w 9 div 4 mul  h 3 div 2 mul
  w h curveto % upper left of >
  w neg Inset neg rlineto % move to x=0 and inset
  gsave fill grestore 
} def 
%
/Tbar { 
  CLW mul add /z ED 
  z -2 div CLW 2 div moveto 
  z 0 rlineto stroke 
  0 CLW moveto 
} def
%
/Bracket { 
  CLW mul add dup CLW sub 2 div 
  /x ED mul CLW add /y ED /z CLW 2 div def 
  x neg y moveto 
  x neg CLW 2 div L x CLW 2 div L x y L stroke 
  0 CLW moveto 
} def
%
/RoundBracket { 
  CLW mul add dup 2 div 
  /x ED mul /y ED /mtrx CM def 
  0 CLW 2 div T x y mul 0 ne { x y scale } if 
  1 1 moveto 
  .85 .5 .35 0 0 0 curveto 
  -.35 0 -.85 .5 -1 1 curveto 
  mtrx setmatrix stroke 0 CLW moveto 
} def
%
/SD { 0 360 arc fill } def
%
/EndDot { % DS is the dot size 
  { /z DS def } { /z 0 def } ifelse  	% outer or inner dimen 
  /b ED 				% the color definition
  0 z DS SD 
  b { 0 z DS CLW sub SD } if 
  0 DS z add CLW 4 div sub 
  moveto 
} def
%
/Shadow { [ { /moveto load } { /lineto load } { /curveto load } {
  /closepath load } /pathforall load stopped { pop pop pop pop CP /moveto
  load } if ] cvx newpath 3 1 roll T exec } def
%
/NArray { % holds the coordinates and on top of stack the showpoints boolean
  /showpoints ED 
  counttomark 2 div dup cvi /n ED  	% n 2 div on stack 
  n eq not { exch pop } if		% even numbers of points? delete one
  ] aload /Points ED 
  showpoints not { Points aload pop } if
%    { ] aload /Points ED } 
%    { n 2 mul 1 add -1 roll pop } ifelse	% delete the mark symbol 
} def
%
/Line { 
  NArray n 0 eq not 
    { n 1 eq { 0 0 /n 2 def } if ArrowA /n n 2 sub def 
      n { Lineto } repeat 
      CP 4 2 roll ArrowB L pop pop 
    } if 
} def
%
/LineToYAxis {
  /Ox ED		% Save the x origin value 
  NArray            % all x-y pairs on stack
  n { 2 copy moveto % go to current point
    Ox exch Lineto   % line to y-axis
    pop             % delete old x-value
  } repeat
} def
%
/LineToXAxis{
  /Oy ED		% Save the y origin value 
  NArray		% all x-y pairs on stack
  n 0 eq not
    { n 1 eq { 0 0 /n 2 def } if
      ArrowA
      /n n 2 sub def
      CP 2 copy moveto pop Oy Lineto
      n { 2 copy moveto pop Oy Lineto } repeat
      CP
      4 2 roll
      ArrowB
      2 copy moveto pop Oy
      L
      pop pop } if
} def
%
/Arcto { 
  /a [ 6 -2 roll ] cvx def 
  a r 
  /arcto load stopped { 5 } { 4 } ifelse { pop } repeat 
  a 
} def
%
/CheckClosed { 
  dup n 2 mul 1 sub index eq 2 index n 2 mul 1 add index eq
  and { pop pop /n n 1 sub def } if 
} def
%
/Polygon { 
  NArray n 2 eq { 0 0 /n 3 def } if 
  n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      n 2 mul -2 roll 
      /y0 ED /x0 ED /y1 ED /x1 ED  
      x1 y1 
      /x1 x0 x1 add 2 div def 
      /y1 y0 y1 add 2 div def 
      x1 y1 moveto 
      /n n 2 sub def 
      n { Lineto } repeat 
      x1 y1 x0 y0 6 4 roll Lineto
      Lineto pop pop closepath } ifelse 
} def
%
/SymbolPolygon {   % on stack [ x y x y ...
  counttomark 					% number of elements
  2 add /m ED
  2 copy m 2 roll				% copy last two
  m 2 div cvi /n ED    				% n pairs
  /YA ED /XA ED					% the start point
  n 1 sub { 
    /YB ED /XB ED
    /XLength XB XA sub def
    /YLength YB YA sub def
    /PAngle YLength XLength Atan def
    /XYLength XLength YLength Pyth def
    /nSym XYLength SymStep Div cvi def
    /Shift Symbol stringwidth pop 2 Div def 
    /deltaX XLength nSym Div def
    /deltaY YLength nSym Div def
    XA Shift sub YA Shift sub moveto 
    nSym { 
      gsave rotateSymbol { PAngle 180 sub CorrAngle sub rotate } if
      Symbol show 
      grestore 
      deltaX deltaY rmoveto
    } repeat
%    XB Shift sub YB Shift sub moveto Symbol show
    /YA YB def /XA XB def
  } repeat 
  pop	% delete the mark symbol
} def
%
/Diamond { 
  /mtrx CM def 
  T rotate 
  /h ED 
  /w ED 
  dup 0 eq { pop } { CLW mul neg 
    /d ED 
    /a w h Atan def 
    /h d a sin Div h add def 
    /w d a cos Div w add def } ifelse 
  mark w 2 div h 2 div w 0 0 h neg w neg 0 0 h w 2 div h 2 div 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false Line 
  closepath mtrx setmatrix } def
%
/Triangle { 
  /mtrx CM def 
  translate 
  rotate /h ED 2 div /w ED 
  dup CLW mul /d ED 
  /h h d w h Atan sin Div sub def 
  /w w d h w Atan 2 div dup cos exch sin Div mul sub def 
  mark 
  0 d w neg d 0 h w d 0 d 
  /ArrowA { moveto } def 
  /ArrowB { } def 
  false 
  Line 
  closepath 
  mtrx
% DG/SR modification begin - Jun.  1, 1998 - Patch 3 (from Michael Vulis)
% setmatrix } def
  setmatrix pop 
} def
% DG/SR modification end
%
/CCA { 
  /y ED /x ED 
  2 copy y sub /dy1 ED 
  x sub /dx1 ED 
  /l1 dx1 dy1 Pyth def 
} def
%
/CC { 
  /l0 l1 def 
  /x1 x dx sub def 
  /y1 y dy sub def 
  /dx0 dx1 def 
  /dy0 dy1 def 
  CCA 
  /dx dx0 l1 c exp mul dx1 l0 c exp mul add def 
  /dy dy0 l1 c exp mul dy1 l0 c exp mul add def 
  /m dx0 dy0 Atan dx1 dy1 Atan sub 2 div cos abs b exp a mul dx dy Pyth Div 2 div def 
  /x2 x l0 dx mul m mul sub def
  /y2 y l0 dy mul m mul sub def 
  /dx l1 dx mul m mul neg def 
  /dy l1 dy mul m mul neg def 
} def
%
/IC { 
  /c c 1 add def 
  c 0 lt { /c 0 def } { c 3 gt { /c 3 def } if } ifelse 
  /a a 2 mul 3 div 45 cos b exp div def 
  CCA 
  /dx 0 def 
  /dy 0 def 
} def
%
/BOC { IC CC x2 y2 x1 y1 ArrowA CP 4 2 roll x y curveto } def
/NC { CC x1 y1 x2 y2 x y curveto } def
/EOC { x dx sub y dy sub 4 2 roll ArrowB 2 copy curveto } def
/BAC { IC CC x y moveto CC x1 y1 CP ArrowA } def
/NAC { x2 y2 x y curveto CC x1 y1 } def
/EAC { x2 y2 x y ArrowB curveto pop pop } def
%
/OpenCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { BOC /n n 3 sub def n { NC } repeat EOC } ifelse 
} def
%
/CurvePath { 
  %% for negative SymStep we calculate the distance 
  SymStep 0 lt { gsave PathLength SymStep div abs /SymStep ED grestore } if
  0.5 setflat
  flattenpath /z 0 def /z0 0 def
  { /y1 ED /x1 ED /y2 y1 def /x2 x1 def 
    x1 Shift sub y1 Shift sub moveto 
    gsave 
    curveticks 
      { x1 y1 translate startAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke      
      }
      { startAngle rotate Symbol show }
    ifelse 
    grestore /z0 z def }
  { /y ED /x ED PathLength@ z z0 sub SymStep ge {
      x Shift sub y Shift sub moveto 
      gsave 
      curveticks 
        { y yOld sub x xOld sub Atan 180 sub CorrAngle sub /rotAngle ED  
          x y translate rotAngle rotate 
          0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
          SymbolLinewidth setlinewidth stroke
        }
        { 
          rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
          Symbol show 
        }
      ifelse 
      grestore /z0 z def } if 
    /yOld y def /xOld x def } 
  {} %% the lineto part
  { /y y2 def /x x2 def PathLength@ 
    x Shift sub y Shift sub moveto 
    gsave
    curveticks 
      { y yOld sub x xOld sub Atan 180 sub /rotAngle ED  
        x y translate rotAngle rotate 
        0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
        SymbolLinewidth setlinewidth stroke
      }
      { 
        x Shift sub y Shift sub moveto 
        rotateSymbol { y yOld sub x xOld sub Atan 180 sub CorrAngle sub rotate } if        
        Symbol show 
      }
    ifelse 
    grestore
  }
  pathforall 
%  curveticks 
%   { gsave 
%     x y translate rotAngle rotate 
%     0 SymbolWidth 2 div moveto 0 SymbolWidth 2 div neg lineto 
%     SymbolLinewidth setlinewidth stroke grestore
%   } if
  z 
} def
%
/OpenSymbolCurve { 
  OpenCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/AltCurve { 
  { false NArray n 2 mul 2 roll 
    [ n 2 mul 3 sub 1 roll ] aload
    /Points ED 
    n 2 mul -2 roll } 
  { false NArray } ifelse 
  n 4 lt { n { pop pop } repeat } { BAC /n n 4 sub def n { NAC } repeat EAC } ifelse 
} def
%
/AltOpenSymbolCurve { 
  AltCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedCurve { 
  NArray n 3 lt 
    { n { pop pop } repeat } 
    { n 3 gt { CheckClosed } if 
      6 copy n 2 mul 6 add 6 roll 
      IC CC x y moveto n { NC } repeat 
      closepath pop pop 
    } ifelse 
} def
%
/ClosedSymbolCurve { 
  ClosedCurve
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/SQ { /r ED r r moveto r r neg L r neg r neg L r neg r L fill } def
/ST { /y ED /x ED x y moveto x neg y L 0 x L fill } def
/SP { /r ED gsave 0 r moveto 4 { 72 rotate 0 r L } repeat fill grestore } def
%
/FontDot { 
  DS 2 mul dup 
  matrix scale matrix concatmatrix exch matrix
  rotate matrix concatmatrix exch 
  findfont exch makefont setfont 
} def
%
/Rect { 
  x1 y1 y2 add 2 div moveto 
  x1 y2 lineto 
  x2 y2 lineto 
  x2 y1 lineto
  x1 y1 lineto 
  closepath 
} def
%
/OvalFrame { 
  x1 x2 eq y1 y2 eq or 
    { pop pop x1 y1 moveto x2 y2 L } 
    { y1 y2 sub abs x1 x2 sub abs 2 copy gt 
      { exch pop } { pop } ifelse 
      2 div exch { dup 3 1 roll mul exch } if 
      2 copy lt { pop } { exch pop } ifelse
      /b ED 
      x1 y1 y2 add 2 div moveto 
      x1 y2 x2 y2 b arcto 
      x2 y2 x2 y1 b arcto
      x2 y1 x1 y1 b arcto 
      x1 y1 x1 y2 b arcto 
      16 { pop } repeat 
      closepath 
    } ifelse 
} def
%
/Frame { 
  CLW mul /a ED 
  3 -1 roll 
  2 copy gt { exch } if 
  a sub /y2 ED 
  a add /y1 ED 
  2 copy gt { exch } if 
  a sub /x2 ED 
  a add /x1 ED 
  1 index 0 eq { pop pop Rect } { OvalFrame } ifelse 
} def
%
/BezierNArray { 
  /f ED 
  counttomark 2 div dup cvi /n ED 
  n eq not { exch pop } if 
  n 1 sub neg 3 mod 3 add 3 mod { 0 0 /n n 1 add def } repeat 
  f { ] aload /Points ED } { n 2 mul 1 add -1 roll pop } ifelse 
} def
%
/OpenBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { ArrowA n 4 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      6 2 roll 4 2 roll ArrowB curveto } ifelse 
} def
%
/OpenSymbolBezier { 
  OpenBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
} def
%
/ClosedBezier { 
  BezierNArray 
  n 1 eq 
    { pop pop } 
    { moveto n 1 sub 3 idiv 
      { 6 2 roll 4 2 roll curveto } repeat 
      closepath } ifelse 
} def
%
/ClosedSymbolBezier { 
  /f ED				 % save showpoints value 
  2 copy /yEnd ED /xEnd ED
  counttomark -2 roll 2 copy /yStart ED /xStart ED
  counttomark 2 roll
  f
  ClosedBezier
  0.1 setflat
  /Shift Symbol stringwidth pop 2 div def 
  CurvePath 
  [ xEnd yEnd xStart yStart SymbolLine 
} def
%
/BezierShowPoints { 
  gsave 
  Points aload length 2 div cvi /n ED 
  moveto 
  n 1 sub { lineto } repeat 
  CLW 2 div SLW [ 4 4 ] 0 setdash stroke 
  grestore 
} def
%
/Parab { 
  /y0 ED /x0 ED /y1 ED /x1 ED 
  /dx x0 x1 sub 3 div def 
  /dy y0 y1 sub 3 div def 
  x0 dx sub y0 dy add x1 y1 ArrowA
  x0 dx add y0 dy add x0 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 x0 y0 x0 2 mul x1 sub y1 ] def 
} def
%
/Parab1 { % 1 end  |  0 SP
  /ySP ED /xSP ED /y1 ED /x1 ED 
  /dx xSP x1 sub 3 div def 
  /dy ySP y1 sub 3 div def 
  newpath x1 y1 moveto xSP y1 lineto xSP ySP lineto 
                       x1 ySP lineto closepath clip 
  currentpoint
  newpath moveto
  xSP dx sub ySP dy add x1 y1 ArrowA
  xSP dx add ySP dy add xSP 2 mul x1 sub y1 ArrowB 
  curveto 
  /Points [ x1 y1 xSP ySP xSP 2 mul x1 sub y1 ] def 
} def
%
/Grid { 
  newpath 
  /a 4 string def 
  /b ED % 				psk@gridlabels in pt
  /c ED % 				{ \pst@usecolor\psgridlabelcolor }
  /n ED % 				psk@griddots
  cvi dup 1 lt { pop 1 } if 
  /s ED % 				\psk@subgriddiv
  s div dup 0 eq { pop 1 } if 
  /dy ED s div dup 0 eq { pop 1 } if %	\pst@number\psyunit abs
  /dx ED dy div round dy mul %		\pst@number\psxunit abs
  /y0 ED dx div round dx mul 
  /x0 ED dy div round cvi 
  /y2 ED dx div round cvi 
  /x2 ED dy div round cvi 
  /y1 ED dx div round cvi 
  /x1 ED 
  /h y2 y1 sub 0 gt { 1 } { -1 } ifelse def 
  /w x2 x1 sub 0 gt { 1 } { -1 } ifelse def 
  b 0 gt { 
    /z1 b 4 div CLW 2 div add def
%    /Helvetica findfont b scalefont setfont 
    /b b .95 mul CLW 2 div add def } if 
  systemdict /setstrokeadjust known 
    { true setstrokeadjust /t { } def }
    { /t { transform 0.25 sub round 0.25 add exch 0.25 sub round 0.25 add
       exch itransform } bind def } ifelse 
  gsave n 0 gt { 1 setlinecap [ 0 dy n div ] dy n div 2 div setdash } { 2 setlinecap } ifelse 
  /i x1 def 
  /f y1 dy mul n 0 gt { dy n div 2 div h mul sub } if def 
  /g y2 dy mul n 0 gt { dy n div 2 div h mul add } if def 
  x2 x1 sub w mul 1 add dup 1000 gt { pop 1000 } if 
  { i dx mul dup y0 moveto 
    b 0 gt 
      { gsave c i a cvs dup stringwidth pop 
        /z2 ED w 0 gt {z1} {z1 z2 add neg} ifelse 
	h 0 gt {b neg}{z1} ifelse 
        rmoveto show grestore } if 
    dup t f moveto 
    g t L stroke 
    /i i w add def 
  } repeat 
  grestore 
  gsave 
  n 0 gt
  % DG/SR modification begin - Nov. 7, 1997 - Patch 1
  %{ 1 setlinecap [ 0 dx n div ] dy n div 2 div setdash }
    { 1 setlinecap [ 0 dx n div ] dx n div 2 div setdash }
  % DG/SR modification end
    { 2 setlinecap } ifelse 
  /i y1 def 
  /f x1 dx mul n 0 gt { dx n div 2 div w mul sub } if def 
  /g x2 dx mul n 0 gt { dx n div 2 div w mul add } if def 
  y2 y1 sub h mul 1 add dup 1000 gt { pop 1000 } if 
  { newpath i dy mul dup x0 exch moveto 
    b 0 gt { gsave c i a cvs dup stringwidth pop 
      /z2 ED 
      w 0 gt {z1 z2 add neg} {z1} ifelse 
      h 0 gt {z1} {b neg} ifelse 
      rmoveto show grestore } if 
    dup f exch t moveto 
    g exch t L stroke 
    /i i h add def 
  } repeat 
  grestore 
} def
%
/ArcArrow { 
  /d ED /b ED /a ED 
  gsave 
  newpath 0 -1000 moveto clip 
  newpath 
  0 1 0 0 b 
  grestore 
  c mul 
  /e ED 
  pop pop pop r a e d PtoC y add exch x add
  exch r a PtoC y add exch x add exch b pop pop pop pop a e d CLW 8 div c
  mul neg d 
} def
%
/Ellipse { 
  /rotAngle ED
  /mtrx CM def 
  T 
  rotAngle rotate
  scale 0 0 1 5 3 roll arc 
  mtrx setmatrix 
} def
%
/ArcAdjust { %%%% Vincent Guirardel
% given a target length (targetLength) and an initial angle (angle0) [in the stack],
% let  M(angle0)=(rx*cos(angle0),ry*sin(angle0))=(x0,y0).
% This computes an angle t such that (x0,y0) is at distance 
% targetLength from the point M(t)=(rx*cos(t),ry*sin(t)).
% NOTE: this an absolute angle, it does not have to be added or substracted to angle0
% contrary to TvZ's code.
% To achieve, this, one iterates the following process: start with some angle t,
% compute the point M' at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)].
% Now take t' (= new angle) so that (0,0) M(t') and M' are aligned.
%
% Another difference with TvZ's code is that we need d (=add/sub) to be defined.
% the value of d = add/sub is used to know on which side we have to move.
% It is only used in the initialisation of the angle before the iteration.
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Input stack:  1: target length 2: initial angle
% variables used : rx, ry, d (=add/sub)
%
  /targetLength ED /angle0 ED
  /x0 rx angle0 cos mul def
  /y0 ry angle0 sin mul def
% we are looking for an angle t such that (x0,y0) is at distance targetLength 
% from the point M(t)=(rx*cos(t),ry*sin(t)))
%initialisation of angle (using 1st order approx = TvZ's code)
  targetLength 57.2958 mul
  angle0 sin rx mul dup mul
  angle0 cos ry mul dup mul
  add sqrt div 
% if initialisation angle is two large (more than 90 degrees) set it to 90 degrees
% (if the ellipse is very curved at the point where we draw the arrow, %
% the value can be much more than 360 degrees !)
% this should avoid going on the wrong side (more than 180 degrees) or go near
% a bad attractive point (at 180 degrees)
  dup 90 ge { pop 90 } if 
  angle0 exch d % add or sub
% maximum number of times to iterate the iterative procedure:
% iterative procedure: takes an angle t on top of stack, computes a 
% better angle (and put it on top of stack)
  30 { dup
% compute distance D between (x0,y0) and M(t)
    dup cos rx mul x0 sub dup mul exch sin ry mul y0 sub dup mul add sqrt
% if D almost equals targetLength, we stop
    dup targetLength sub abs 1e-5 le { pop exit } if
% stack now contains D t
% compute the point M(t') at distance targetLength of (x0,y0) on the semi-line [(x0,y0) M(t)]:
% M(t')= ( (x(t)-x0)*targetLength/d+x0 , (y(t)-y0)*targetLength/d+y0 )
    exch dup cos rx mul x0 sub  exch sin ry mul y0 sub
% stack contains:  y(t)-y0, x(t)-x0, d
    2 index Div targetLength mul y0 add ry Div exch
    2 index Div targetLength mul x0 add rx Div
% stack contains x(t')/rx , y(t')/ry , d
% now compute t', and remove D from stack
    atan exch pop
  } repeat
% we don't look at what happened... in particular, if targetLength is greater 
% than the diameter of the ellipse...
% the final angle will be around /angle0 + 180. maybe we should treat this pathological case...
% after iteration, stack contains an angle t such that M(t) is the tail of the arrow
% to give back the result as a an angle relative to angle0 we could add the following line:
% angle0 sub 0 exch d
%
% begin bug fix 2006-01-11
% we want to adjust the new angle t' by a multiple of 360 so that  | t'-angle0 | <= 180
%(we don't want to make the ellipse turn more or less than it should)...
dup angle0 sub dup abs 180 gt { 180 add 360 div floor 360 mul sub } { pop } ifelse
% end bug fix
} def
%
/EllipticArcArrow {
  /d ED      % is add or sub
  /b ED      % arrow procedure
  /a1 ED     % angle
  gsave
  newpath
  0 -1000 moveto
  clip                  % Set clippath far from arrow.
  newpath
  0 1 0 0 b             % Draw arrow to determine length.
  grestore
% Length of arrow is on top of stack. Next 3 numbers are junk.
%
  a1 exch ArcAdjust   % Angular position of base of arrow.
  /a2 ED
  pop pop pop
  a2 cos rx mul xOrig add % hv 2007-08-29   x->xOrig
  a2 sin ry mul yOrig add % hv 2007-08-29   y->yOrig
  a1 cos rx mul xOrig add % 
  a1 sin ry mul yOrig add % 
% Now arrow tip coor and base coor are on stack.
  b pop pop pop pop       % Draw arrow, and discard coordinates.
  a2 CLW 8 div
% change value of d (test it by looking if  `` 1 1 d '' gives 2 or not )
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse
  ArcAdjust
% resets original value of d
  1 1 d 2 eq { /d { sub } def } { /d { add } def } ifelse  % Adjust angle to give overlap.
} def
%%------------------ tvz/DG/hv (2004-05-10) end -------------------%%
%
/Rot { CP CP translate 3 -1 roll neg rotate NET  } def
%
/RotBegin { 
  tx@Dict /TMatrix known not { /TMatrix { } def /RAngle { 0 } def } if 
  /TMatrix [ TMatrix CM ] cvx def 
  /a ED 
  a Rot /RAngle [ RAngle dup a add ] cvx def 
} def
%
/RotEnd { 
  /TMatrix [ TMatrix setmatrix ] cvx def 
  /RAngle [ RAngle pop ] cvx def 
} def
%
/PutCoor { gsave CP T CM STV exch exec moveto setmatrix CP grestore } def
/PutBegin { /TMatrix [ TMatrix CM ] cvx def CP 4 2 roll T moveto } def
/PutEnd { CP /TMatrix [ TMatrix setmatrix ] cvx def moveto } def
%
/Uput {
  /a ED 
  add 2 div /h ED 2 
  div /w ED 
  /s a sin def 
  /c a cos def 
  /b s abs c abs 2 copy gt dup 
    /q ED 
    { pop } { exch pop } ifelse def 
  /w1 c b div w mul def 
  /h1 s b div h mul def 
  q { w1 abs w sub dup c mul abs }{ h1 abs h sub dup s mul abs } ifelse 
} def
%
/UUput { 
  5 dict begin
  /z ED 
  abs /y ED 
  /x ED 
  q { x s div c mul abs y gt }{ x c div s mul abs y gt } ifelse 
    { x x mul y y mul sub z z mul add sqrt z add } 
    { q { x s div } { x c div } ifelse abs 
    } ifelse 
  a PtoC 
  h1 add exch 
  w1 add exch 
  end
} def
%
end
%-----------------------------------------------------------------------------%
%
% END pstricks.pro

%%EndProcSet
%%BeginProcSet: pst-algparser.pro 0 0
% $Id: pst-algparser.pro 801 2013-07-09 18:10:41Z herbert $
%%
%% PostScript prologue for PSTricks algorithm parser
%% Version 0.04, 2011/10/21
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%%-----------------------------------------------------------------------------%
%
/AlgParser { tx@AlgToPs begin AlgToPs end } def  % Dominique Rodriguez
%
/tx@CoreAnalyzerDict 100 dict def tx@CoreAnalyzerDict begin
%
% PS ANALYZER FOR ALGEBRAIC EXPRESSION V1.13
%
% 09/2011 DR factorial with ! added
%
% E->T|E+T
% T->FS|T*FS
% FS -> F | +FS | -FS
% F->P|F^SF|P!
% P->(E)|literal
% literal->number|var|var[E]|func(params)
% params->E|E,param
% number->TOBEFINISHED
%
%% E expression, T term, SF signed factor, F factor, P power
%
%% parser
%
%% str
%
%% C->E<condition_operators>E
%% STR index -> STR index+lenExpr
/AnalyzeCond { AnalyzeExpr ReadCondOp AnalyzeExpr EvalCondOp  } def
%
%% analyze Expression List (separator , or | )
%% STR index -> STR index+lenExpr
%% /AnalyzeListOfE {
%%   { NextNonBlankChar pop AnalyzeExpr%%dup Strlen eq { exit } if NextNonBlankChar
%%     NextNonBlankChar dup 0 eq { pop exit } if
%%     dup 44 ne 1 index 124 ne and { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse } if
%%     pop NextNonBlankChar dup 0 eq { exit } if 124 ne { PROBLEMCONTACTBILLOU } if 1 add NextNonBlankChar 0 eq {toto} if } loop
%%   AnalyzeListOfEPostHook
%% } def
/AnalyzeListOfE {
  /NotFirst false def
  { NextNonBlankChar pop AnalyzeExpr
    NotFirst { EvalListOfExpr } { /NotFirst true def } ifelse
    dup Strlen eq { exit } if NextNonBlankChar
    dup 44 ne 1 index 124 ne and
    { dup 41 ne { PROBLEMCONTACTBILLOU } { pop exit } ifelse }
    if  pop 1 add } loop
  AnalyzeListOfEPostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% E->T|E+T
%% STR index -> STR index+lenExpr
/AnalyzeExpr {
  AnalyzePreHook AnalyzeTerm IsEndingExpr
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeTerm PreEvalHook EvalAddSub IsEndingExpr { pop exit } if } loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% T->FS|T*FS
%% STR index
/AnalyzeTerm {
  AnalyzePreHook AnalyzeSignedFactor IsEndingTerm
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor PreEvalHook EvalMulDiv IsEndingTerm { pop exit } if} loop }
  ifelse
  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% FS -> F | +FS | -FS
%% STR index
/AnalyzeSignedFactor {
  AnalyzePreHook 2 copy get dup IsUnaryOp
  { RollOp 1 add NextNonBlankChar pop AnalyzeSignedFactor EvalUnaryOp }
  { pop AnalyzeFactor }
  ifelse AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% F->P|F^P|P!
%% STR index
/AnalyzeFactor {
  AnalyzePreHook AnalyzePower IsEndingFactor
  { dup 0 ne { 32 eq { NextNonBlankChar } if } { pop } ifelse }
  { { dup 33 eq%% is there a ! DR 09/2011
      { pop 1 add NextNonBlankChar pop EvalFactorial }
      { RollOp 1 add NextNonBlankChar pop AnalyzePower PreEvalHook EvalPower }
      ifelse
      IsEndingFactor { pop exit } if } loop }
  ifelse  AnalyzePostHook
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% P->(E)|literal
%% STR index
/AnalyzePower {
  %% depending of first char either a number, or a literal
  2 copy get dup 40 eq%%an open par
  { pop 1 add NextNonBlankChar pop AnalyzeExpr 1 add NextNonBlankChar pop }
  { AnalyzeLiteral }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index STR[index] -> STR index
%/AnalyzeLiteral { IsNumber { EvalNumber } { EvalLiteral } ifelse } def
/AnalyzeLiteral { dup IsUnaryOp exch IsNumber or { EvalNumber } { EvalLiteral } ifelse } def%%dr 09102006
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% recognize + or -
%% chr -> T/F
/IsUnaryOp { dup 43 eq exch 45 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsNumber { dup 48 ge exch dup 57 le 3 -1 roll and exch 46 eq or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadNumber {
  exch dup 3 -1 roll dup 3 1 roll
  %%read mantissa
  { 1 add  2 copy dup Strlen eq { pop pop 0 exit } if get dup IsNumber not { exit } if pop } loop
  dup 101 eq exch 69 eq or
  %%% there is a "e" or "E" -> read exponant
  { 1 add 2 copy get dup IsUnaryOp
    { pop 1 add 2 copy get } if
    { IsNumber not { exit } if 1 add 2 copy get } loop }
  if
  dup 4 1 roll
  3 -1 roll exch 1 index sub getinterval
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a number can contain only : 0123456789.
%% chr -> T/F
/IsCondOp { dup 30 eq exch dup 60 ge exch 62 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index number
%% a number can be of the form [0-9]*.[0-9]*\([eE][+-]?[0-9]+\)?
%% STR index -> STR index' number
/ReadCondOp {
  NextNonBlankChar 1 index 4 1 roll
  { IsCondOp not { exit } if 1 add  2 copy get } loop
  2 copy 5 -1 roll
  exch 1 index sub getinterval 3 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can contain only : 0123456789.
%% chr -> T/F
/IsLiteral {%
  dup 48 ge exch dup  57 le 3 -1 roll and exch
  dup 65 ge exch dup  90 le 3 -1 roll and 3 -1 roll or exch
  dup 97 ge exch     122 le and or } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% a literal can be of the form [a-zA-Z][a-zA-Z0-9]*\(\((Expression)\)|\(\[Expression\]\)\)?
%% STR index -> literal STR index' nextchr
/ReadLiteral {
  exch dup 3 -1 roll dup 3 1 roll
  %%read literal core
  { 2 copy dup Strlen eq { pop pop 0 exit } if get dup IsLiteral not { exit } if pop 1 add } loop
  4 1 roll dup 5 1 roll 3 -1 roll exch 1 index sub getinterval 4 1 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a clpar
%% STR index -> STR index STR[index] T/F
/IsEndingExpr {%
  2 copy dup Strlen eq
  %% if end of str is reached -> end !
  { pop pop 0 true }
  %% ending chr -> clpar, comma, |, <, >, =, !,
  {get dup  dup  41 eq
       exch dup 124 eq
       exch dup  93 eq
       exch dup  44 eq
       exch dup  30 eq
       exch dup  60 ge exch 62 le and or or or or or}
  ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or a +-
%% STR index -> STR index STR[index] T/F
/IsEndingTerm { IsEndingExpr { true } { dup dup 43 eq exch 45 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or */
%% STR index -> STR index STR[index] T/F
/IsEndingFactor { IsEndingTerm { true } { dup dup 42 eq exch 47 eq or } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% expr is ended by end of str or ^
%% STR index -> STR index STR[index] T/F
/IsEndingPower { IsEndingFactor { true } { dup 94 eq } ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% STR index -> STR index STR[index]
/NextNonBlankChar { { dup Strlen eq { 0 exit } if 2 copy get dup neBlkChar { exit } if pop 1 add } loop } bind def
/neBlkChar { dup 32 ne exch dup 10 ne exch 9 ne and and } bind def
%%%%%%%%%%%%%%%%%%%%%%%%
%% DEBUG
/BRK {false} def
/BRKtrue {/BRK true def} def
/BRKStop {BRK {BRKtoto} if } def
/BRKEvalStop {BRK exch if } def
/BRKBRK2true {BRK {BRK2true} if } def
/BRK2 {false} def
/BRK2true {/BRK2 true def} def
/BRK2Stop {BRK2 {BRK2toto} if } def/BRK {false} def
end
%
%-------------------------------------------------------------------------------%
%
/tx@AlgToPs 12 dict def tx@AlgToPs begin
%
%% algExpr -> PSVector
/AlgToPs { tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE pop pop EndingSequence end } def
/EndingSequence { ExpressionVector aload length /end cvx exch 1 add array astore } def
/InitParser { /ExpressionVector [ /tx@AddMathFunc cvx /begin cvx ] def dup length /Strlen exch def 0 } def
/Strlen 0 def
/EvalListOfExpr {} def%
/EvalNumber {%
    ReadNumber  cvr /ExpressionVector ExpressionVector aload length dup 3 add -1 roll cvx
    exch 1 add array astore def NextNonBlankChar pop } def
/EvalAddSub {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  43 eq { /add } { /sub } ifelse cvx exch 1 add array astore def
} def
/EvalMulDiv {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  42 eq { /mul } { /div } ifelse cvx exch 1 add array astore def
} def
/EvalPower {%
  /ExpressionVector ExpressionVector aload length dup 5 add -1 roll
  pop /exp cvx exch 1 add array astore def
} def
/EvalFactorial {% DR 09/2011
  /ExpressionVector ExpressionVector aload length
  /fact cvx exch 1 add array astore def
} def
/EvalLiteral {%
  ReadLiteral
  dup 40 eq%%% there is an open par -> function call
  { pop 2 index
    dup (Sum) eq { EvalSum }
    { dup (IfTE) eq { EvalCond }
      { dup (Derive) eq { pop EvalDerive }
	{ pop 1 add NextNonBlankChar pop AnalyzeListOfE 2 index TrigoFunc
          /ExpressionVector ExpressionVector aload length dup 5 add -1 roll cvn cvx
	  exch 1 add array astore def 1 add NextNonBlankChar pop } ifelse } ifelse} ifelse }
  { /ExpressionVector ExpressionVector aload length dup 6 add -1 roll cvn cvx exch 1 add array astore def
    dup 91 eq%%% there is an open bracket -> vector element
    { pop 1 add NextNonBlankChar pop AnalyzeExpr
      /ExpressionVector ExpressionVector aload length /cvi cvx exch /get cvx exch 2 add array astore def 1 add }
    { pop NextNonBlankChar pop }
    ifelse}
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the derive function : Derive(n,f(x))
%% firstparindex lastparindex ->
/EvalDerive {
  %% manage the function descripiton
  1 add ReadNumber 3 1 roll NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  1 add NextNonBlankChar pop
  3 -1 roll cvi
  dup 0 eq
  { pop AnalyzeExpr 3 -1 roll pop 1 add }
  { 1 sub 3 1 roll (x)  exch tx@Derive begin DeriveIndexed end 4 -1 roll
    { (x) tx@Derive begin Derive end } repeat
    ExpressionVector exch /ExpressionVector [] def
    AlgToPs aload length
    /ExpressionVector 1 index 3 add -1 roll aload length dup 3 add -1 roll  /l2 exch def /l1 exch def
    l1 l2 add 1 add l2 neg roll l1 l2 add array astore def 3 -1 roll pop 1 add
    1 index length /Strlen exch def } ifelse
} def
/EvalSum {%
  pop 1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber cvi 3 1 roll
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  /ExpressionVector ExpressionVector aload length dup 7 add -3 roll 0 4 1 roll
  5 -1 roll 4 add array astore def
  %% keep ExpressionVector for later and create a new one for internal Sum computation
  ExpressionVector 3 1 roll /ExpressionVector [ 6 -1 roll cvn /exch cvx /def cvx ] def
  1 add NextNonBlankChar pop AnalyzeExpr
  %% add each term
  /ExpressionVector ExpressionVector aload length 1 add /add cvx exch array astore def
  /ExpressionVector 4 -1 roll aload length ExpressionVector cvx /for cvx 3 -1 roll 2 add
  array astore def 3 -1 roll pop 1 add
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
/EvalCond {%
  pop 1 add AnalyzeCond NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  ExpressionVector 3 1 roll /ExpressionVector [] def
  1 add AnalyzeExpr ExpressionVector 3 1 roll /ExpressionVector [] def
  NextNonBlankChar 44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add AnalyzeExpr
  NextNonBlankChar 41 ne { ANALYZER_ERROR_missing_ending parenthesis_in_IfTE } if
  ExpressionVector
  /ExpressionVector 6 -1 roll aload length dup
  6 add -1 roll cvx exch dup 4 add -1 roll cvx /ifelse cvx 3 -1 roll 3 add array astore def
  1 add 3 -1 roll pop
} def
%% CondOp STR index
/EvalCondOp {%
  3 -1 roll
  dup (=) eq  { /eq } {%
  dup (<) eq  { /lt } {%
  dup (>) eq  { /gt } {%
  dup (>=) eq { /ge } {%
  dup (<=) eq { /ge } {%
  dup (!=) eq { /ne } { ERROR_non_valid_conditional_operator }
  ifelse } ifelse } ifelse } ifelse } ifelse } ifelse
  cvx exch pop
  /ExpressionVector ExpressionVector aload length dup 3 add -1 roll exch 1 add array astore def } def
/EvalUnaryOp {
  3 -1 roll 45 eq { /ExpressionVector ExpressionVector aload length /neg cvx exch 1 add array astore def } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook {} bind def
/PreEvalHook {} bind def
/AnalyzeListOfEPostHook {} bind def
/AnalyzePostHook {} def
/RollOp { 3 1 roll } bind def
end   %tx@CoreAnalyzerDict
%
%--------------------------------------------------------------------%
%
/tx@Derive 41 dict def tx@Derive begin
%%increase ^^ for each function added
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable -> PSVector
/Derive {%
  10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser AnalyzeListOfE end
} def
/Strlen 0 def
/InitParser { dup length /Strlen exch def 0 } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% algExpr variable index -> PSVector
/DeriveIndexed {%
  3 1 roll 10240 string 3 1 roll 0 3 1 roll
  /Variable exch def
  tx@CoreAnalyzerDict begin InitParser pop 4 -1 roll AnalyzeExpr 4 -2 roll pop pop 4 -2 roll exch pop end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u,v)'=-(u',v')
/EvalListOfExpr {%
  4 2 roll 2 copy 9 -1 roll dup length 4 1 roll putinterval add AddPipe
           2 copy 7 -1 roll dup length 4 1 roll putinterval add
  6 -2 roll pop pop
  2 copy pop 0 6 2 roll GetIntervalNewStr 5 1 roll 2 copy 0 exch getinterval 6 1 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (-u)'=-(u')
/EvalUnaryOp {
  4 -2 roll 4 index (0) eq
  { (0) StrConcat 7 -1 roll pop }
  { 7 -1 roll 45 eq
    { AddSub AddOpPar true } { false } ifelse
    3 1 roll 5 index StrConcat 3 -1 roll { AddClPar } if } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  7 -2 roll pop pop 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (number)'=0
/EvalNumber { ReadNumber (0) 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u+v)'=u'+v'
/EvalAddSub {%
  7 index dup (0) eq
  { pop true }%% du=0 nothing added
  { dup length exch 5 index 5 index 3 -1 roll putinterval 4 -1 roll add 3 1 roll false }
  ifelse
  5 index dup (0) eq
  { pop { (0) } { 4 -2 roll 2 copy pop 0  6 2 roll GetIntervalNewStr } ifelse }%%dv=0
  { exch
    { 5 -2 roll 7 index 45 eq { AddSub } if false } %%nothing yet added
    { 5 -2 roll 7 index 43 eq%%something yet added
      { AddAdd false } { AddSub AddOpPar true } ifelse }
    ifelse 11 1 roll
    3 -1 roll StrConcat 10 -1 roll { AddClPar } if
    2 copy pop 0 6 2 roll GetIntervalNewStr }
  ifelse
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)' or (u/v)'
/EvalMulDiv { 6 index 42 eq {EvalMul} {EvalDiv} ifelse } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u*v)'=u'*v+u*v'
/EvalMul {%
  4 -2 roll 7 index dup (0) eq
  { pop false }%%du=0
  { (1) eq%%du=1
    { false }
    { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
    3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if
    true }%%du!=0
  ifelse
  5 1 roll 5 index (0) eq
  { 5 -1 roll not { (0) StrConcat } if }%%dv=0
  { 5 -1 roll { AddAdd } if
    4 index (1) eq
    { 8 index StrConcat }
    { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
    ifelse
  }%%dv!=0
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u/v)'=(u'*v-u*v')/v^2
/EvalDiv {%
  4 -2 roll
  4 index (0) eq%%dv=0 -> u'/v
  { 7 index (0) eq { (0) StrConcat } { AddOpPar 7 index StrConcat AddClPar AddDiv 5 index StrConcat } ifelse }
  { 7 index dup (0) eq
    { pop }%%du=0
    { (1) eq%%du=1
      { false }
      { AddOpPar 7 index StrConcat AddClPar AddMul AddOpPar true } ifelse
      3 1 roll 6 index StrConcat 3 -1 roll { AddClPar } if}%%du!=0
    ifelse
      AddSub
      4 index (1) eq
      { 8 index StrConcat }
      { AddOpPar 8 index StrConcat AddClPar AddMul AddOpPar 4 index StrConcat AddClPar }
      ifelse
    %}%%dv!=0
    2 copy GetIntervalNewStr 3 1 roll pop 0 AddOpPar 3 -1 roll StrConcat AddClPar
    AddDiv AddOpPar 5 index StrConcat AddClPar 2 copy (^2) putinterval 2 add }
  ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str1 index str2 -> str1 index
/StrConcat { dup length 4 2 roll 2 copy 6 -1 roll putinterval 3 -1 roll add } bind def
/GetIntervalNewStr { 0 exch getinterval dup length string copy } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (u^v)'=(u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
/EvalPower {%
  4 -2 roll 7 index (0) eq
  {%%if du=0 then (u^v)'=v'ln(u)u^v
    4 index (0) eq
    { (0) StrConcat }%%if dv=0 then (u^v)'=0
    { 4 index (1) ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if
      8 index (e) ne { (ln\() StrConcat 8 index StrConcat (\)*) StrConcat } if
      AddOpPar 8 index StrConcat (\)^\() StrConcat 5 index StrConcat AddClPar } ifelse
  }
  {%%du!=0
    4 index (0) eq
    {%%if dv=0 then (u^v)'=vu'u^(v-1)
      5 index dup IsStrNumber
      { dup (0) eq
        { StrConcat }
        { dup dup (1) eq exch (1.0) eq or
          { StrConcat  }
	  { StrConcat
	    7 index dup (1) ne exch (1.0) ne and%%%dr 09102006 insert du if <> 1
	    { (*\() StrConcat 7 index StrConcat (\)) StrConcat } if%%%dr 09102006
            (*\() StrConcat 8 index StrConcat (\)) StrConcat
            5 index  dup dup (2) eq exch (2.0) eq or
	    { pop } { cvr 1 sub 20 string cvs 3 1 roll (^) StrConcat 3 -1 roll StrConcat } ifelse } ifelse } ifelse }
      { pop AddOpPar 5 index StrConcat (\)*\() StrConcat 8 index StrConcat (\)^\() StrConcat
        5 index StrConcat (-1\)) StrConcat } ifelse
    }
    {%%if dv!=0 and du!=0 then (u^v)'=u'vu^(v-1)+v'u^(v)ln(u)
      7 index (1) ne { AddOpPar 7 index StrConcat (\)*) StrConcat } if
      AddOpPar 5 index StrConcat (\)*\() StrConcat
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (-1\)+\() StrConcat
      4 index (1) ne { 4 index StrConcat (\)*\() StrConcat } if
      8 index StrConcat (\)^\() StrConcat
      5 index StrConcat (\)*ln\() StrConcat
      8 index StrConcat AddClPar
    } ifelse
  } ifelse
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for factorial ! only cst => null derivative
/EvalFactorial {% DR 09/2011
  4 index (0) eq
  { (0) mark 8 -2 roll  cleartomark 2 index 7 index dup 4 index exch sub getinterval exch 6 2 roll }
  { DERIVATIVE_ENGINE_ERROR_no_variable_in_factorial } ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% str -> true/false
/IsStrNumber {%
  true exch
  { dup 48 lt exch dup 57 gt 3 -1 roll or
    exch dup 46 ne%%.
    exch dup 43 ne%%+
    exch 45 ne%%-
    and and and { pop false } if } forall
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalLiteral {%
  ReadLiteral dup 40 eq%%% there is an open par -> function call
  { pop (EvalFunc_             ) 9 4 index StrConcat 0 exch getinterval cvn cvx exec }
  { dup 91 eq%%% there is an open bracket -> vector element
    { DERIVATIVE_ENGINE_ERROR_vector_not_yet_implemented }
    { pop EvalVariable }
    ifelse }
  ifelse
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% first last parpos Expr[first:parpos-1] ->
/EvalVariable { 2 index Variable eq { (1) } { (0) } ifelse 4 -1 roll exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% (f(u))'=u'f'(u)
/EvalFunc {
  4 2 roll 4 index (1) ne
  { AddOpPar 4 index StrConcat (\)*) StrConcat } if
  (Eval             ) 4 8 index StrConcat 0 exch getinterval cvn cvx exec
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Func derivative -> Eval<func>
/EvalFunc_sin {%
  PreCommonFunc
  { (cos\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_cos {%
  PreCommonFunc
  { (\(-sin\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_tan {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/cos\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_asin {%
  PreCommonFunc
  { (1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_acos {%
  PreCommonFunc
  { (-1/sqrt\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_atg {%
  PreCommonFunc
  { (1/\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_ln {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_exp {%
  PreCommonFunc
  {  (exp\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_EXP {%
  PreCommonFunc
  {  (EXP\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_sqrt {%
  PreCommonFunc
  { dup 0 eq { (1) StrConcat } { 1 sub } ifelse (/\(2*sqrt\() StrConcat 5 index StrConcat (\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Fact {%
  PreCommonFunc { DERIVATIVE_ENGINE_ERROR_no_variable_expression_in_Fact } if
  PostCommonFunc } def
/EvalFunc_sh {%
  PreCommonFunc
  { (ch\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_ch {%
  PreCommonFunc
  { (sh\() StrConcat 5 index StrConcat AddClPar } if
  PostCommonFunc } def
/EvalFunc_th {%
  PreCommonFunc
  {  dup 0 eq { (1) StrConcat } { 1 sub } ifelse  (/ch\() StrConcat 5 index StrConcat (\)^2) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argsh {%
  PreCommonFunc
  { (1/sqrt\(1+\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argch {%
  PreCommonFunc
  { (1/sqrt\(\() StrConcat 5 index StrConcat (\)^2-1\)\)) StrConcat } if
  PostCommonFunc } def
/EvalFunc_Argth {%
  PreCommonFunc
  { (1/\(1-\() StrConcat 5 index StrConcat (\)^2\)\)) StrConcat } if
  PostCommonFunc } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
/PreCommonFunc {
  1 add NextNonBlankChar pop 3 -1 roll 5 1 roll AnalyzeExpr 1 add NextNonBlankChar pop
  4 2 roll 4 index (0) eq
  { (0) StrConcat false }
  { 4 index (1)  ne { AddOpPar 4 index StrConcat (\)*) StrConcat } if true } ifelse
} def
/PostCommonFunc {
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
/EvalFunc_Derive {%
  1 add ReadNumber cvi 1 add dup cvr log 1 add cvi string cvs
  4 -1 roll pop 5 1 roll 1 add NextNonBlankChar pop AnalyzeExpr 1 add
  4 -2 roll (Derive\() StrConcat 7 -1 roll StrConcat (,) StrConcat 6 -1 roll StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr 6 -1 roll pop 2 index 6 index dup 4 index exch sub getinterval
  exch 6 2 roll } def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_Sum {%
  1 add NextNonBlankChar pop
  %% read the variable name
  ReadLiteral pop 3 -1 roll pop NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_Sum } if
  %% read the initial value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_second_comma_in_Sum } if
  %% read the increment value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_third_comma_in_Sum } if
  %% read the limit value
  1 add NextNonBlankChar pop ReadNumber pop
  2 copy get 44 ne { ANALYZER_ERROR_missing_fourth_comma_in_Sum } if
  1 add NextNonBlankChar pop dup 6 1 roll 3 -1 roll pop AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 8 index dup 9 index exch sub getinterval StrConcat
  4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 9 -3 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% literal switch -> func call, vector, variables
/EvalFunc_IfTE {%
  3 -1 roll pop 1 add NextNonBlankChar pop SkipCond
  NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_first_comma_in_IfTE } if
  1 add NextNonBlankChar pop dup 5 1 roll
  AnalyzeExpr NextNonBlankChar
  44 ne { ANALYZER_ERROR_missing_second_comma_in_IfTE } if
  1 add NextNonBlankChar pop
  AnalyzeExpr 1 add NextNonBlankChar pop
  4 -2 roll 3 index 10 index dup 11 index exch sub getinterval StrConcat
  6 index StrConcat (,) StrConcat 4 index StrConcat AddClPar
  2 copy pop 0 6 2 roll GetIntervalNewStr
  mark 11 -5 roll cleartomark 2 index 6 index dup 4 index exch sub getinterval exch 6 2 roll
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% advance in str until a comma is found (no error detection!)
%% str index -> str index'
/SkipCond { { 1 add 2 copy get 44 eq {exit } if } loop } bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Convert to radians if trigo function call
%% (name) ->
/TrigoFunc {
  dup (cos) eq 1 index (sin) eq or exch (tan) eq or
  { /ExpressionVector ExpressionVector aload length Pi /div cvx 180 /mul cvx 5 -1 roll 4 add
    array astore def
  } if
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% No derivative for condition....
/EvalCondOp { 3 -1 roll pop } bind def
/PutIntervalOneAdd {putinterval 1 add} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddOpPar {2 copy (\() PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add close parenthesis in string at the given index
%% str index -> str index+1
/AddClPar {2 copy (\)) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add 0 in string at the given index
%% str index -> str index+1
/AddZero {2 copy (0) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddMul {2 copy (*) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add open parenthesis in string at the given index
%% str index -> str index+1
/AddDiv {2 copy (/) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a plus sign in string at the given index
%% str index -> str index+1
/AddAdd {2 copy (+) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a minus sign in string at the given index
%% str index -> str index+1
/AddSub {2 copy (-) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Add a pipe sign in string at the given index
%% str index -> str index+1
/AddPipe {2 copy (|) PutIntervalOneAdd} bind def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% H O O K S
/AnalyzePreHook { dup 5 1 roll } bind def
/PreEvalHook {} def
/AnalyzePostHook { 7 -1 roll pop } bind def
/AnalyzeListOfEPostHook { 6 -1 roll mark 6 1 roll cleartomark } bind def
/RollOp { 5 1 roll } bind def
end%%%tx@CoreAnalyzerDict
/tx@AddMathFunc 12 dict def tx@AddMathFunc begin
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% NEW FUNC
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% function arcsine in radians asin(x)=atan(x/sqrt(1-x^2))
%% x -> theta
/asin {%
  dup abs 1 gt { EQDFasinrangeerror  } if
  dup dup dup mul 1 exch sub sqrt atan exch 0 lt { 360 sub } if DegtoRad
} def
%% function arccosine in radians acos(x)=atan(sqrt(1-x^2)/x)
%% x -> theta
/acos {%
  dup abs 1 gt { EQDFacosrangeerror  } if
  dup dup mul 1 exch sub sqrt exch atan DegtoRad
} def
%% function arctangent in radians
%% x -> theta
/atg { 1 atan dup 90 gt { 360 sub } if DegtoRad } bind def
%% HYPERBOLIC FUNCTIONS
/sh { dup Ex exch neg Ex sub 2 div } def
/ch { dup Ex exch neg Ex add 2 div } def
/th { dup sh exch ch div } def
/Argsh { dup dup mul 1 add sqrt add ln } def
/Argch { dup dup mul 1 sub sqrt add ln } def
/Argth { dup 1 add exch 1 exch sub div ln 2 div } def
%% modified exponential funtion for 0
%% x n -> x^n
/Exp { dup 0 eq { pop pop 1 } { exp } ifelse } bind def
%% modified exponential funtion for 0
%% x -> e^x
/Ex { Euler exch exp } bind def
%%
%% factorial function
%% n -> n!
/Fact { 1 exch 2 exch 1 exch { mul } for } bind def
/fact { Fact } bind def
/! { Fact } bind def
end
%
% END pst-algparser.pro

%%EndProcSet
%%BeginProcSet: pst-tools.pro 0 0
% $Id: pst-tools.pro 842 2013-10-26 10:25:41Z herbert $
%
%% PostScript tools prologue for pstricks.tex.
%% Version 0.04, 2013/10/26
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%
%
/Pi2 1.57079632679489661925640 def
/factorial { % n on stack, returns n! 
  dup 0 eq { 1 }{ 
    dup 1 gt { dup 1 sub factorial mul } if }
  ifelse } def 
%
/MoverN { % m n on stack, returns the binomial coefficient m over n
  2 dict begin
  /n exch def /m exch def
  n 0 eq { 1 }{
    m n eq { 1 }{
      m factorial n factorial m n sub factorial mul div } ifelse } ifelse 
  end
} def
%
/ps@ReverseOrderOfPoints { % on stack [P1 P2 P3 ...Pn]=>[Pn,Pn-1,...,P2,P1]
  5 dict begin       % all local
  aload length /n ED % number of coors
  n 2 div cvi /m ED  % number of Points
  /n1 n def
  m { n1 2 roll /n1 n1 2 sub def } repeat
  n array astore
  end
} def
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% subroutines for complex numbers, given as an array [a b] 
% which is a+bi = Real+i Imag
%
/cxadd {		% [a1 b1] [a2 b2] = [a1+a2 b1+b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  3 -1 roll		% [a2 b2] a2 [a1 b1]
  dup 0 get		% [a2 b2] a2 [a1 b1] a1
  3 -1 roll		% [a2 b2] [a1 b1] a1 a2
  add			% [a2 b2] [a1 b1] a1+a2
  3 1 roll		% a1+a2 [a2 b2] [a1 b1]
  1 get			% a1+a2 [a2 b2] b1
  exch 1 get		% a1+a2 b1 b2
  add 2 array astore
} def
%
/cxneg {		% [a b]
  dup 1 get		% [a b] b
  exch 0 get		% b a
  neg exch neg		% -a -b
  2 array astore
} def
%
/cxsub { cxneg cxadd } def  % same as negative addition
%
% [a1 b1][a2 b2] = [a1a2-b1b2 a1b2+b1a2] = [a3 b3]
/cxmul {		% [a1 b1] [a2 b2]
  dup 0 get		% [a1 b1] [a2 b2] a2
  exch 1 get		% [a1 b1] a2 b2
  3 -1 roll		% a2 b2 [a1 b1]
  dup 0 get		% a2 b2 [a1 b1] a1
  exch 1 get		% a2 b2 a1 b1
  dup			% a2 b2 a1 b1 b1
  5 -1 roll dup		% b2 a1 b1 b1 a2 a2
  3 1 roll mul		% b2 a1 b1 a2 b1a2
  5 -2 roll dup		% b1 a2 b1a2 b2 a1 a1
  3 -1 roll dup		% b1 a2 b1a2 a1 a1 b2 b2
  3 1 roll mul		% b1 a2 b1a2 a1 b2 a1b2
  4 -1 roll add		% b1 a2 a1 b2 b3
  4 2 roll mul		% b1 b2 b3 a1a2
  4 2 roll mul sub	% b3 a3
  exch 2 array astore
} def
%
% [a b]^2 = [a^2-b^2 2ab] = [a2 b2]
/cxsqr {		% [a b]   square root
  dup 0 get exch 1 get	% a b
  dup dup mul		% a b b^2
  3 -1 roll		% b b^2 a
  dup dup mul 		% b b^2 a a^2
  3 -1 roll sub		% b a a2
  3 1 roll mul 2 mul	% a2 b2	
  2 array astore
} def
%
/cxsqrt {		% [a b]
%  dup cxnorm sqrt /r exch def
%  cxarg 2 div RadtoDeg dup cos r mul exch sin r mul cxmake2 
  cxlog 		% log[a b]
  2 cxrdiv 		% log[a b]/2
  aload pop exch	% b a
  2.781 exch exp	% b exp(a)
  exch cxconv exch	% [Re +iIm] exp(a)
  cxrmul		%
} def
%
/cxarg { 		% [a b] 
  aload pop 		% a b
  exch atan 		% arctan b/a
  DegtoRad 		% arg(z)=atan(b/a)
} def
%
% log[a b] = [a^2-b^2 2ab] = [a2 b2]
/cxlog {		% [a b]
  dup 			% [a b][a b]
  cxnorm 		% [a b] |z|
  log 			% [a b] log|z|
  exch 			% log|z|[a b]
  cxarg 		% log|z| Theta
  cxmake2 		% [log|z| Theta]
} def
%
% square of magnitude of complex number
/cxnorm2 {		% [a b]
  dup 0 get exch 1 get	% a b
  dup mul			% a b^2
  exch dup mul add	% a^2+b^2
} def
%
/cxnorm {		% [a b]
  cxnorm2 sqrt
} def
%
/cxconj {		% conjugent complex
  dup 0 get exch 1 get	% a b
  neg 2 array astore	% [a -b]
} def
%
/cxre { 0 get } def	% real value
/cxim { 1 get } def	% imag value
%
% 1/[a b] = ([a -b]/(a^2+b^2)
/cxrecip {		% [a b]
  dup cxnorm2 exch	% n2 [a b]
  dup 0 get exch 1 get	% n2 a b
  3 -1 roll		% a b n2
  dup			% a b n2 n2
  4 -1 roll exch div	% b n2 a/n2
  3 1 roll div		% a/n2 b/n2
  neg 2 array astore
} def
%
/cxmake1 { 0 2 array astore } def % make a complex number, real given
/cxmake2 { 2 array astore } def	  % dito, both given
%
/cxdiv { cxrecip cxmul } def
%
% multiplikation by a real number
/cxrmul {		% [a b] r
  exch aload pop	% r a b
  3 -1 roll dup		% a b r r
  3 1 roll mul		% a r b*r
  3 1 roll mul		% b*r a*r
  exch 2 array astore   % [a*r b*r]
} def
%
% division by a real number
/cxrdiv {		% [a b] r
  1 exch div		% [a b] 1/r
  cxrmul
} def
%
% exp(i theta) = cos(theta)+i sin(theta) polar<->cartesian
/cxconv {		% theta
  RadtoDeg dup sin exch cos cxmake2
} def

%%%%% ### bubblesort ###
%% syntax : array bubblesort --> array2 trie par ordre croissant
%% code de Bill Casselman
%% http://www.math.ubc.ca/people/faculty/cass/graphics/text/www/
/bubblesort { % on stack must be an array [ ... ]
4 dict begin
   /a exch def
   /n a length 1 sub def
   n 0 gt {
      % at this point only the n+1 items in the bottom of a remain to
      % the sorted largest item in that blocks is to be moved up into
      % position n
      n {
         0 1 n 1 sub {
            /i exch def
            a i get a i 1 add get gt {
               % if a[i] > a[i+1] swap a[i] and a[i+1]
               a i 1 add
               a i get
               a i a i 1 add get
               % set new a[i] = old a[i+1]
               put
               % set new a[i+1] = old a[i]
               put
            } if
         } for
         /n n 1 sub def
      } repeat
   } if
   a % return the sorted array
end
} def
%
/concatstringarray{  %  [(a) (b) ... (z)] --> (ab...z)  20100422
  0 1 index { length add } forall 
  string     
  0 3 2 roll      
  { 3 copy putinterval length add }forall 
  pop  
} bind def
%
/dot2comma {% on stack a string (...) 
  2 dict begin
  /Output exch def
  0 1 Output length 1 sub { 
    /Index exch def 
    Output Index get 46 eq { Output Index 44 put } if 
  } for
  Output
  end
} def
%
/rightTrim { % on stack the string and the character number to be stripped  
  /charNo exch def
  dup
  length 1 sub -1 0 { 
    /i exch def dup i get charNo ne { exit } if 
  } for
  0 i 1 add getinterval
  dup length string copy
} bind def  % leaves the stripped string on the stack

/psStringwidth /stringwidth load def
/psShow /show load def

%/stringwidth{ 32 rightTrim psStringwidth } bind def

%/show { 32 rightTrim psShow } bind def
%-----------------------------------------------------------------------------%

/pgffunctions {
    /pgfsc{}bind def% stroke color is empty by default
    /pgffc{}bind def% fill color is empty by default
    /pgfstr{stroke}bind def%
    /pgffill{fill}bind def%
    /pgfeofill{eofill}bind def%
    /pgfe{a dup 0 rlineto exch 0 exch rlineto neg 0 rlineto closepath}bind def% rectangle
    /pgfw{setlinewidth}bind def% setlinewidth
    /pgfs{save pgfpd 72 Resolution div 72 VResolution div neg scale 
      magscale{1 DVImag div dup scale}if 
      pgfx neg pgfy neg translate pgffoa .setopacityalpha}bind def% save
    /pgfr{pgfsd restore}bind def %restore
    userdict begin%
    /pgfo{pgfsd /pgfx currentpoint /pgfy exch def def @beginspecial}bind def %open
    /pgfc{newpath @endspecial pgfpd}bind def %close
    /pgfsd{globaldict /pgfdelta /delta where {pop delta} {0} ifelse put}bind def% save delta
    /pgfpd{/delta globaldict /pgfdelta get def}bind def % put delta
    /.setopacityalpha where {pop} {/.setopacityalpha{pop}def} ifelse % install .setopacityalpha 
    /.pgfsetfillopacityalpha{/pgffoa exch def
      /pgffill{gsave pgffoa .setopacityalpha fill 1 .setopacityalpha newpath fill grestore newpath}bind def
      /pgfeofill{gsave pgffoa .setopacityalpha eofill 1 .setopacityalpha newpath eofill grestore newpath}bind def}bind def
    /.pgfsetstrokeopacityalpha{/pgfsoa exch def /pgfstr{gsave pgfsoa .setopacityalpha stroke grestore newpath}bind def}bind def
    /pgffoa 1 def
    /pgfsoa 1 def
    end
} def
%-----------------------------------------------------------------------------%
% END pst-tools.pro

%%EndProcSet
%%BeginProcSet: pst-dots.pro 0 0
% $Id: pst-dots.pro 801 2013-07-09 18:10:41Z herbert $
%
%% PostScript prologue for pstricks.tex.
%% Version 2.02,  2009/06/16
%%
%% For distribution, see pstricks.tex.
%%
%% Timothy Van Zandt <tvz@Princeton.EDU>
%%
%% This program can be redistributed and/or modified under the terms
%% of the LaTeX Project Public License Distributed from CTAN archives
%% in directory macros/latex/base/lppl.txt.
%%
%% Modified by Etienne Riga  - Dec. 16, 1999
%% Modified by Etienne Riga  - 2005/01/01 (er)
%% to add /Diamond, /SolidDiamond and /BoldDiamond
%% Modified by Herbert Voss (hv) - 2008/04/17 
%
10 dict dup begin			% hold local
  /FontType 3 def
  /FontMatrix [.001 0 0 .001 0 0] def
%  /FontBBox [-571.5 -742.5 571.5 742.5] def % changed to next line 20060616 hv
  /FontBBox [-1000 -1000 1000 1000] def  % See end of file in /BuildGlyph
  /Encoding 256 array def
  0 1 255 {Encoding exch /.notdef put} for % fill the array with /.notdef
  Encoding				   % replace with given dot names
    dup (b) 0 get /Bullet put		   % get the numerical position of b in ASCII
%					   % and save /Bullet at this place in Encoding 
    dup (c) 0 get /Circle put
    dup (C) 0 get /BoldCircle put	% 67
    dup (u) 0 get /SolidTriangle put
    dup (t) 0 get /Triangle put
    dup (T) 0 get /BoldTriangle put
    dup (r) 0 get /SolidSquare put
    dup (s) 0 get /Square put
    dup (S) 0 get /BoldSquare put
    dup (q) 0 get /SolidPentagon put
    dup (p) 0 get /Pentagon put
    dup (P) 0 get /BoldPentagon put
%%%		  
    dup (k) 0 get /Asterisk put
    dup (K) 0 get /BoldAsterisk put
    dup (J) 0 get /SolidAsterisk put
    dup (h) 0 get /Hexagon put
    dup (H) 0 get /BoldHexagon put
    dup (G) 0 get /SolidHexagon put
    dup (f) 0 get /Octogon put		% 2008-04-18 hv
    dup (F) 0 get /BoldOctogon put	% 2008-04-18 hv
    dup (g) 0 get /SolidOctogon put	% 2008-04-18 hv
    dup (a) 0 get /Add put
    dup (A) 0 get /BoldAdd put 		% 65
    dup (x) 0 get /Mul put
    dup (X) 0 get /BoldMul put
    dup (m) 0 get /Oplus put
    dup (M) 0 get /BOplus put
    dup (e) 0 get /SolidOplus put
    dup (n) 0 get /Otimes put
    dup (N) 0 get /BOtimes put
    dup (E) 0 get /SolidOtimes put
    dup (i) 0 get /Bar put
    dup (I) 0 get /BoldBar put
    dup (l) 0 get /SolidDiamond put
    dup (d) 0 get /Diamond put
        (D) 0 get /BoldDiamond put
%%%  
/CharProcs 47 dict def
CharProcs begin
  /CirclePath {0 0 500 0 360 arc closepath} def
  /Bullet {CirclePath fill} def
  /Circle {CirclePath .9 .9 scale CirclePath eofill} def
  /BoldCircle {CirclePath .8 .8 scale CirclePath eofill} def
  /TrianglePath {0 660 moveto -571.5 -330 lineto 571.5 -330 lineto closepath} def
  /SolidTriangle {TrianglePath fill} def
  /Triangle {TrianglePath .85 .85 scale TrianglePath eofill} def
  /BoldTriangle {TrianglePath .7 .7 scale TrianglePath eofill} def
  /SquarePath {-450 450 moveto 450 450 lineto 450 -450 lineto -450 -450 lineto closepath} def
  /SolidSquare {SquarePath fill} def
  /Square {SquarePath .89 .89 scale SquarePath eofill} def
  /BoldSquare {SquarePath .78 .78 scale SquarePath eofill} def
  /PentagonPath {
    -337.8 -465 moveto 337.8 -465 lineto 546.6 177.6 lineto
    0 574.7 lineto -546.6 177.6 lineto closepath
  } def
  /SolidPentagon {PentagonPath fill} def
  /Pentagon {PentagonPath .89 .89 scale PentagonPath eofill} def
  /BoldPentagon {PentagonPath .78 .78 scale PentagonPath eofill} def
%-------------- hv begin 2004/07/25   from: er 2003/03/24
  /HexagonPath {
    0 550 moveto -476 275 lineto -476 -275 lineto
    0 -550 lineto 476 -275 lineto 476 275 lineto closepath
  } def
  /SolidHexagon {HexagonPath fill} def
  /Hexagon {HexagonPath .89 .89 scale HexagonPath eofill} def
  /BoldHexagon {HexagonPath .79 .79 scale HexagonPath eofill} def
%					2008-04-18 hv
  /OctogonPath { 
     550 dup 22.5 tan mul dup neg dup add /xMove exch def 
     exch moveto 7 { xMove 0 rlineto 45 rotate } repeat closepath } def 
  /SolidOctogon { OctogonPath fill                             } def
  /Octogon {      OctogonPath .89 .89 scale OctogonPath eofill } def
  /BoldOctogon {  OctogonPath .79 .79 scale OctogonPath eofill } def
%
  /AsteriskPath {
    20 0 moveto 10 250 180 500 0 500 curveto
    -180 500 -10 250 -20 0 curveto closepath
  } def
  /Asterisk {
    AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath
    60 rotate AsteriskPath 60 rotate AsteriskPath 60 rotate AsteriskPath fill
  } def
%
  /Basterp {50 250 220 500 0 500 curveto -220 500 -50 250 -50 30 cos 100 mul curveto} def
  /BoldAsteriskPath {
    50 30 cos 100 mul moveto  Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp 60 rotate Basterp
    60 rotate Basterp closepath
  } def
  /BoldAsterisk {BoldAsteriskPath fill} def
  /SolidAsterisk {CirclePath .9 .9 scale BoldAsteriskPath eofill} def
  /CrossPath {
    40 550 moveto -40 550 lineto -40 40 lineto -550 40 lineto
    -550 -40 lineto -40 -40 lineto -40 -550 lineto 40 -550 lineto 
    40 -40 lineto 550 -40 lineto 550 40 lineto 40 40 lineto closepath
  } def
  /BoldCrossPath {80 550 moveto -80 550 lineto -80 80 lineto -550 80 lineto
    -550 -80 lineto -80 -80 lineto -80 -550 lineto 80 -550 lineto 
    80 -80 lineto 550 -80 lineto 550 80 lineto 80 80 lineto closepath
  } def
  /Add {CrossPath fill} def
  /Mul {45 rotate CrossPath fill} def
  /BoldAdd {BoldCrossPath fill} def
  /BoldMul {45 rotate BoldCrossPath fill} def
  /Oplus {CirclePath .9 .9 scale CirclePath eofill .775 .775 scale CrossPath fill } def 
  /SolidOplus {CirclePath .775 .775 scale BoldCrossPath eofill} def 
  /BOplus {CirclePath .8 .8 scale CirclePath eofill .775 .775 scale BoldCrossPath fill} def 
  /Otimes {CirclePath .9 .9 scale CirclePath eofill 45 rotate .775 .775 scale CrossPath fill} def 
  /BOtimes {CirclePath .8 .8 scale CirclePath eofill 45 rotate .775 .775 scale BoldCrossPath fill } def 
  /SolidOtimes {CirclePath 45 rotate .775 .775 scale BoldCrossPath eofill} def 
  /BarPath {40 660 moveto -40 660 lineto -40 -660 lineto 40 -660 lineto closepath} def
  /Bar {BarPath fill} def
  /BoldBarPath {80 660 moveto -80 660 lineto -80 -660 lineto 80 -660 lineto closepath} def
  /BoldBar {BoldBarPath fill} def
  /DiamondPath {0 742.5 moveto -428.5 0 lineto 0 -742.5 lineto 428.5 0 lineto closepath} def
  /SolidDiamond {DiamondPath fill} def
  /Diamond {DiamondPath .865 .865 scale DiamondPath eofill} def
  /BoldDiamond {DiamondPath .73 .73 scale DiamondPath eofill} def
%%%
  /.notdef { } def
end
%
/BuildGlyph {
  exch
  begin 		
%  Metrics 1 index get exec 0
    0 0
%      BBoxes 3 index get exec
    -1000 -1000 1000 1000
%     -571.5 -742.5 571.5 742.5
    setcachedevice
    CharProcs begin load exec end
  end
} def
%
/BuildChar {
  1 index /Encoding get exch get
  1 index /BuildGlyph get exec
} bind def
%
end
/PSTricksDotFont exch definefont pop
%
%% end

%%EndProcSet
%%BeginProcSet: pst-text.pro 0 0
%!
% PostScript header file pst-text.pro
% Version 1.0, 2005-11-29 (hv)
% For distribution, see pstricks.tex.

/tx@TextPathDict 40 dict def
tx@TextPathDict begin

% Syntax:  <dist> PathPosition -
% Function: Searches for position of currentpath distance <dist> from
%           beginning. Sets (X,Y)=position, and Angle=tangent.
/PathPosition
{ /targetdist exch def
  /pathdist 0 def
  /continue true def
  /X { newx } def /Y { newy } def /Angle 0 def
  gsave
    flattenpath
    { movetoproc }  { linetoproc } { } { firstx firsty linetoproc }
    /pathforall load stopped { pop pop pop pop /X 0 def /Y 0 def } if
  grestore
} def

/movetoproc { continue { @movetoproc } { pop pop } ifelse } def

/@movetoproc
{ /newy exch def /newx exch def
  /firstx newx def /firsty newy def
} def

/linetoproc { continue { @linetoproc } { pop pop } ifelse } def

/@linetoproc {
  /oldx newx def /oldy newy def
  /newy exch def /newx exch def
  /dx newx oldx sub def
  /dy newy oldy sub def
  /dist dx dup mul dy dup mul add sqrt def
  /pathdist pathdist dist add def
  pathdist targetdist ge
  { pathdist targetdist sub dist div dup
    dy mul neg newy add /Y exch def
    dx mul neg newx add /X exch def
    /Angle dy dx atan def
    /continue false def
  } if
} def

/TextPathShow { 
  /String exch def
  /CharCount 0 def
% hv begin 2005-11-29   1.00
%   String length
%   { String CharCount 1 getinterval ShowChar
%     /CharCount CharCount 1 add def
   /CharSize 1 def
   currentfont /FontType get 0 eq
   { currentfont /FMapType get dup 2 eq exch dup 5 eq exch 9 eq or or
     { /CharSize 2 def} if
   } if
   String length CharSize idiv
   { String CharCount CharSize getinterval ShowChar
     /CharCount CharCount CharSize add def
% hv end 2005-11-29   1.00
  } repeat
} def

% Syntax: <pathlength> <position> InitTextPath -
/InitTextPath
{ gsave
    currentpoint /Y exch def /X exch def
    exch X Hoffset sub sub mul
    Voffset Hoffset sub add
    neg X add /Hoffset exch def
    /Voffset Y def
  grestore
} def

/Transform
{ PathPosition
  dup
  Angle cos mul Y add exch
  Angle sin mul neg X add exch
  translate
  Angle rotate
} def

/ShowChar { 
  /Char exch def
  gsave
    Char end stringwidth
    tx@TextPathDict begin
    2 div /Sy exch def 2 div /Sx exch def

%%%  MV 10-09-99 00:36
    /sc?currentpoint where {pop sc?currentpoint} {currentpoint} ifelse
%   currentpoint

    Voffset sub Sy add exch
    Hoffset sub Sx add
    Transform
    Sx neg Sy neg moveto
    Char end tx@TextPathSavedShow
    tx@TextPathDict begin
  grestore
  Sx 2 mul Sy 2 mul rmoveto
} def
%
end
% END pst-text.pro

%%EndProcSet
%%BeginProcSet: 8r.enc 0 0
% File 8r.enc  TeX Base 1 Encoding  Revision 2.0  2002-10-30
%
% @@psencodingfile@{
%   author    = "S. Rahtz, P. MacKay, Alan Jeffrey, B. Horn, K. Berry,
%                W. Schmidt, P. Lehman",
%   version   = "2.0",
%   date      = "27nov06",
%   filename  = "8r.enc",
%   email     = "tex-fonts@@tug.org",
%   docstring = "This is the encoding vector for Type1 and TrueType
%                fonts to be used with TeX.  This file is part of the
%                PSNFSS bundle, version 9"
% @}
% 
% The idea is to have all the characters normally included in Type 1 fonts
% available for typesetting. This is effectively the characters in Adobe
% Standard encoding, ISO Latin 1, Windows ANSI including the euro symbol,
% MacRoman, and some extra characters from Lucida.
% 
% Character code assignments were made as follows:
% 
% (1) the Windows ANSI characters are almost all in their Windows ANSI
% positions, because some Windows users cannot easily reencode the
% fonts, and it makes no difference on other systems. The only Windows
% ANSI characters not available are those that make no sense for
% typesetting -- rubout (127 decimal), nobreakspace (160), softhyphen
% (173). quotesingle and grave are moved just because it's such an
% irritation not having them in TeX positions.
% 
% (2) Remaining characters are assigned arbitrarily to the lower part
% of the range, avoiding 0, 10 and 13 in case we meet dumb software.
% 
% (3) Y&Y Lucida Bright includes some extra text characters; in the
% hopes that other PostScript fonts, perhaps created for public
% consumption, will include them, they are included starting at 0x12.
% These are /dotlessj /ff /ffi /ffl.
% 
% (4) hyphen appears twice for compatibility with both ASCII and Windows.
%
% (5) /Euro was assigned to 128, as in Windows ANSI
%
% (6) Missing characters from MacRoman encoding incorporated as follows:
%
%     PostScript      MacRoman        TeXBase1
%     --------------  --------------  --------------
%     /notequal       173             0x16
%     /infinity       176             0x17
%     /lessequal      178             0x18
%     /greaterequal   179             0x19
%     /partialdiff    182             0x1A
%     /summation      183             0x1B
%     /product        184             0x1C
%     /pi             185             0x1D
%     /integral       186             0x81
%     /Omega          189             0x8D
%     /radical        195             0x8E
%     /approxequal    197             0x8F
%     /Delta          198             0x9D
%     /lozenge        215             0x9E
%
/TeXBase1Encoding [
% 0x00
 /.notdef /dotaccent /fi /fl
 /fraction /hungarumlaut /Lslash /lslash
 /ogonek /ring /.notdef /breve
 /minus /.notdef /Zcaron /zcaron
% 0x10
 /caron /dotlessi /dotlessj /ff
 /ffi /ffl /notequal /infinity
 /lessequal /greaterequal /partialdiff /summation
 /product /pi /grave /quotesingle
% 0x20
 /space /exclam /quotedbl /numbersign
 /dollar /percent /ampersand /quoteright
 /parenleft /parenright /asterisk /plus
 /comma /hyphen /period /slash
% 0x30
 /zero /one /two /three
 /four /five /six /seven
 /eight /nine /colon /semicolon
 /less /equal /greater /question
% 0x40
 /at /A /B /C
 /D /E /F /G
 /H /I /J /K
 /L /M /N /O
% 0x50
 /P /Q /R /S
 /T /U /V /W
 /X /Y /Z /bracketleft
 /backslash /bracketright /asciicircum /underscore
% 0x60
 /quoteleft /a /b /c
 /d /e /f /g
 /h /i /j /k
 /l /m /n /o
% 0x70
 /p /q /r /s
 /t /u /v /w
 /x /y /z /braceleft
 /bar /braceright /asciitilde /.notdef
% 0x80
 /Euro /integral /quotesinglbase /florin
 /quotedblbase /ellipsis /dagger /daggerdbl
 /circumflex /perthousand /Scaron /guilsinglleft
 /OE /Omega /radical /approxequal
% 0x90
 /.notdef /.notdef /.notdef /quotedblleft
 /quotedblright /bullet /endash /emdash
 /tilde /trademark /scaron /guilsinglright
 /oe /Delta /lozenge /Ydieresis
% 0xA0
 /.notdef /exclamdown /cent /sterling
 /currency /yen /brokenbar /section
 /dieresis /copyright /ordfeminine /guillemotleft
 /logicalnot /hyphen /registered /macron
% 0xB0
 /degree /plusminus /twosuperior /threesuperior
 /acute /mu /paragraph /periodcentered
 /cedilla /onesuperior /ordmasculine /guillemotright
 /onequarter /onehalf /threequarters /questiondown
% 0xC0
 /Agrave /Aacute /Acircumflex /Atilde
 /Adieresis /Aring /AE /Ccedilla
 /Egrave /Eacute /Ecircumflex /Edieresis
 /Igrave /Iacute /Icircumflex /Idieresis
% 0xD0
 /Eth /Ntilde /Ograve /Oacute
 /Ocircumflex /Otilde /Odieresis /multiply
 /Oslash /Ugrave /Uacute /Ucircumflex
 /Udieresis /Yacute /Thorn /germandbls
% 0xE0
 /agrave /aacute /acircumflex /atilde
 /adieresis /aring /ae /ccedilla
 /egrave /eacute /ecircumflex /edieresis
 /igrave /iacute /icircumflex /idieresis
% 0xF0
 /eth /ntilde /ograve /oacute
 /ocircumflex /otilde /odieresis /divide
 /oslash /ugrave /uacute /ucircumflex
 /udieresis /yacute /thorn /ydieresis
] def


%%EndProcSet
%%BeginProcSet: texps.pro 0 0
%!
TeXDict begin/rf{findfont dup length 1 add dict begin{1 index/FID ne 2
index/UniqueID ne and{def}{pop pop}ifelse}forall[1 index 0 6 -1 roll
exec 0 exch 5 -1 roll VResolution Resolution div mul neg 0 0]FontType 0
ne{/Metrics exch def dict begin Encoding{exch dup type/integertype ne{
pop pop 1 sub dup 0 le{pop}{[}ifelse}{FontMatrix 0 get div Metrics 0 get
div def}ifelse}forall Metrics/Metrics currentdict end def}{{1 index type
/nametype eq{exit}if exch pop}loop}ifelse[2 index currentdict end
definefont 3 -1 roll makefont/setfont cvx]cvx def}def/ObliqueSlant{dup
sin S cos div neg}B/SlantFont{4 index mul add}def/ExtendFont{3 -1 roll
mul exch}def/ReEncodeFont{CharStrings rcheck{/Encoding false def dup[
exch{dup CharStrings exch known not{pop/.notdef/Encoding true def}if}
forall Encoding{]exch pop}{cleartomark}ifelse}if/Encoding exch def}def
end

%%EndProcSet
%%BeginProcSet: special.pro 0 0
%!
TeXDict begin/SDict 200 dict N SDict begin/@SpecialDefaults{/hs 612 N
/vs 792 N/ho 0 N/vo 0 N/hsc 1 N/vsc 1 N/ang 0 N/CLIP 0 N/rwiSeen false N
/rhiSeen false N/letter{}N/note{}N/a4{}N/legal{}N}B/@scaleunit 100 N
/@hscale{@scaleunit div/hsc X}B/@vscale{@scaleunit div/vsc X}B/@hsize{
/hs X/CLIP 1 N}B/@vsize{/vs X/CLIP 1 N}B/@clip{/CLIP 2 N}B/@hoffset{/ho
X}B/@voffset{/vo X}B/@angle{/ang X}B/@rwi{10 div/rwi X/rwiSeen true N}B
/@rhi{10 div/rhi X/rhiSeen true N}B/@llx{/llx X}B/@lly{/lly X}B/@urx{
/urx X}B/@ury{/ury X}B/magscale true def end/@MacSetUp{userdict/md known
{userdict/md get type/dicttype eq{userdict begin md length 10 add md
maxlength ge{/md md dup length 20 add dict copy def}if end md begin
/letter{}N/note{}N/legal{}N/od{txpose 1 0 mtx defaultmatrix dtransform S
atan/pa X newpath clippath mark{transform{itransform moveto}}{transform{
itransform lineto}}{6 -2 roll transform 6 -2 roll transform 6 -2 roll
transform{itransform 6 2 roll itransform 6 2 roll itransform 6 2 roll
curveto}}{{closepath}}pathforall newpath counttomark array astore/gc xdf
pop ct 39 0 put 10 fz 0 fs 2 F/|______Courier fnt invertflag{PaintBlack}
if}N/txpose{pxs pys scale ppr aload pop por{noflips{pop S neg S TR pop 1
-1 scale}if xflip yflip and{pop S neg S TR 180 rotate 1 -1 scale ppr 3
get ppr 1 get neg sub neg ppr 2 get ppr 0 get neg sub neg TR}if xflip
yflip not and{pop S neg S TR pop 180 rotate ppr 3 get ppr 1 get neg sub
neg 0 TR}if yflip xflip not and{ppr 1 get neg ppr 0 get neg TR}if}{
noflips{TR pop pop 270 rotate 1 -1 scale}if xflip yflip and{TR pop pop
90 rotate 1 -1 scale ppr 3 get ppr 1 get neg sub neg ppr 2 get ppr 0 get
neg sub neg TR}if xflip yflip not and{TR pop pop 90 rotate ppr 3 get ppr
1 get neg sub neg 0 TR}if yflip xflip not and{TR pop pop 270 rotate ppr
2 get ppr 0 get neg sub neg 0 S TR}if}ifelse scaleby96{ppr aload pop 4
-1 roll add 2 div 3 1 roll add 2 div 2 copy TR .96 dup scale neg S neg S
TR}if}N/cp{pop pop showpage pm restore}N end}if}if}N/normalscale{
Resolution 72 div VResolution 72 div neg scale magscale{DVImag dup scale
}if 0 setgray}N/psfts{S 65781.76 div N}N/startTexFig{/psf$SavedState
save N userdict maxlength dict begin/magscale true def normalscale
currentpoint TR/psf$ury psfts/psf$urx psfts/psf$lly psfts/psf$llx psfts
/psf$y psfts/psf$x psfts currentpoint/psf$cy X/psf$cx X/psf$sx psf$x
psf$urx psf$llx sub div N/psf$sy psf$y psf$ury psf$lly sub div N psf$sx
psf$sy scale psf$cx psf$sx div psf$llx sub psf$cy psf$sy div psf$ury sub
TR/showpage{}N/erasepage{}N/setpagedevice{pop}N/copypage{}N/p 3 def
@MacSetUp}N/doclip{psf$llx psf$lly psf$urx psf$ury currentpoint 6 2 roll
newpath 4 copy 4 2 roll moveto 6 -1 roll S lineto S lineto S lineto
closepath clip newpath moveto}N/endTexFig{end psf$SavedState restore}N
/@beginspecial{SDict begin/SpecialSave save N gsave normalscale
currentpoint TR @SpecialDefaults count/ocount X/dcount countdictstack N}
N/@setspecial{CLIP 1 eq{newpath 0 0 moveto hs 0 rlineto 0 vs rlineto hs
neg 0 rlineto closepath clip}if ho vo TR hsc vsc scale ang rotate
rwiSeen{rwi urx llx sub div rhiSeen{rhi ury lly sub div}{dup}ifelse
scale llx neg lly neg TR}{rhiSeen{rhi ury lly sub div dup scale llx neg
lly neg TR}if}ifelse CLIP 2 eq{newpath llx lly moveto urx lly lineto urx
ury lineto llx ury lineto closepath clip}if/showpage{}N/erasepage{}N
/setpagedevice{pop}N/copypage{}N newpath}N/@endspecial{count ocount sub{
pop}repeat countdictstack dcount sub{end}repeat grestore SpecialSave
restore end}N/@defspecial{SDict begin}N/@fedspecial{end}B/li{lineto}B
/rl{rlineto}B/rc{rcurveto}B/np{/SaveX currentpoint/SaveY X N 1
setlinecap newpath}N/st{stroke SaveX SaveY moveto}N/fil{fill SaveX SaveY
moveto}N/ellipse{/endangle X/startangle X/yrad X/xrad X/savematrix
matrix currentmatrix N TR xrad yrad scale 0 0 1 startangle endangle arc
savematrix setmatrix}N end

%%EndProcSet
%%BeginProcSet: color.pro 0 0
%!
TeXDict begin/setcmykcolor where{pop}{/setcmykcolor{dup 10 eq{pop
setrgbcolor}{1 sub 4 1 roll 3{3 index add neg dup 0 lt{pop 0}if 3 1 roll
}repeat setrgbcolor pop}ifelse}B}ifelse/TeXcolorcmyk{setcmykcolor}def
/TeXcolorrgb{setrgbcolor}def/TeXcolorgrey{setgray}def/TeXcolorgray{
setgray}def/TeXcolorhsb{sethsbcolor}def/currentcmykcolor where{pop}{
/currentcmykcolor{currentrgbcolor 10}B}ifelse/DC{exch dup userdict exch
known{pop pop}{X}ifelse}B/GreenYellow{0.15 0 0.69 0 setcmykcolor}DC
/Yellow{0 0 1 0 setcmykcolor}DC/Goldenrod{0 0.10 0.84 0 setcmykcolor}DC
/Dandelion{0 0.29 0.84 0 setcmykcolor}DC/Apricot{0 0.32 0.52 0
setcmykcolor}DC/Peach{0 0.50 0.70 0 setcmykcolor}DC/Melon{0 0.46 0.50 0
setcmykcolor}DC/YellowOrange{0 0.42 1 0 setcmykcolor}DC/Orange{0 0.61
0.87 0 setcmykcolor}DC/BurntOrange{0 0.51 1 0 setcmykcolor}DC
/Bittersweet{0 0.75 1 0.24 setcmykcolor}DC/RedOrange{0 0.77 0.87 0
setcmykcolor}DC/Mahogany{0 0.85 0.87 0.35 setcmykcolor}DC/Maroon{0 0.87
0.68 0.32 setcmykcolor}DC/BrickRed{0 0.89 0.94 0.28 setcmykcolor}DC/Red{
0 1 1 0 setcmykcolor}DC/OrangeRed{0 1 0.50 0 setcmykcolor}DC/RubineRed{
0 1 0.13 0 setcmykcolor}DC/WildStrawberry{0 0.96 0.39 0 setcmykcolor}DC
/Salmon{0 0.53 0.38 0 setcmykcolor}DC/CarnationPink{0 0.63 0 0
setcmykcolor}DC/Magenta{0 1 0 0 setcmykcolor}DC/VioletRed{0 0.81 0 0
setcmykcolor}DC/Rhodamine{0 0.82 0 0 setcmykcolor}DC/Mulberry{0.34 0.90
0 0.02 setcmykcolor}DC/RedViolet{0.07 0.90 0 0.34 setcmykcolor}DC
/Fuchsia{0.47 0.91 0 0.08 setcmykcolor}DC/Lavender{0 0.48 0 0
setcmykcolor}DC/Thistle{0.12 0.59 0 0 setcmykcolor}DC/Orchid{0.32 0.64 0
0 setcmykcolor}DC/DarkOrchid{0.40 0.80 0.20 0 setcmykcolor}DC/Purple{
0.45 0.86 0 0 setcmykcolor}DC/Plum{0.50 1 0 0 setcmykcolor}DC/Violet{
0.79 0.88 0 0 setcmykcolor}DC/RoyalPurple{0.75 0.90 0 0 setcmykcolor}DC
/BlueViolet{0.86 0.91 0 0.04 setcmykcolor}DC/Periwinkle{0.57 0.55 0 0
setcmykcolor}DC/CadetBlue{0.62 0.57 0.23 0 setcmykcolor}DC
/CornflowerBlue{0.65 0.13 0 0 setcmykcolor}DC/MidnightBlue{0.98 0.13 0
0.43 setcmykcolor}DC/NavyBlue{0.94 0.54 0 0 setcmykcolor}DC/RoyalBlue{1
0.50 0 0 setcmykcolor}DC/Blue{1 1 0 0 setcmykcolor}DC/Cerulean{0.94 0.11
0 0 setcmykcolor}DC/Cyan{1 0 0 0 setcmykcolor}DC/ProcessBlue{0.96 0 0 0
setcmykcolor}DC/SkyBlue{0.62 0 0.12 0 setcmykcolor}DC/Turquoise{0.85 0
0.20 0 setcmykcolor}DC/TealBlue{0.86 0 0.34 0.02 setcmykcolor}DC
/Aquamarine{0.82 0 0.30 0 setcmykcolor}DC/BlueGreen{0.85 0 0.33 0
setcmykcolor}DC/Emerald{1 0 0.50 0 setcmykcolor}DC/JungleGreen{0.99 0
0.52 0 setcmykcolor}DC/SeaGreen{0.69 0 0.50 0 setcmykcolor}DC/Green{1 0
1 0 setcmykcolor}DC/ForestGreen{0.91 0 0.88 0.12 setcmykcolor}DC
/PineGreen{0.92 0 0.59 0.25 setcmykcolor}DC/LimeGreen{0.50 0 1 0
setcmykcolor}DC/YellowGreen{0.44 0 0.74 0 setcmykcolor}DC/SpringGreen{
0.26 0 0.76 0 setcmykcolor}DC/OliveGreen{0.64 0 0.95 0.40 setcmykcolor}
DC/RawSienna{0 0.72 1 0.45 setcmykcolor}DC/Sepia{0 0.83 1 0.70
setcmykcolor}DC/Brown{0 0.81 1 0.60 setcmykcolor}DC/Tan{0.14 0.42 0.56 0
setcmykcolor}DC/Gray{0 0 0 0.50 setcmykcolor}DC/Black{0 0 0 1
setcmykcolor}DC/White{0 0 0 0 setcmykcolor}DC end

%%EndProcSet
%%BeginFont: StandardSymL
%!PS-AdobeFont-1.0: StandardSymL 001.005
%%CreationDate: Thu Oct 21 1999
% Copyright URW Software, Copyright 1997 by URW
% URW Software, Copyright 1997 by URW
% See the file COPYING (GNU General Public License) for license conditions.
% As a special exception, permission is granted to include this font
% program in a Postscript or PDF file that consists of a document that
% contains text to be displayed or printed using this font, regardless
% of the conditions or license applying to the document itself.
12 dict begin
/FontInfo 10 dict dup begin
/version (001.005) readonly def
/Notice (URW Software, Copyright 1997 by URW. See the file COPYING (GNU General Public License) for license conditions. As a special exception, permission is granted to include this font program in a Postscript or PDF file that consists of a document that contains text to be displayed or printed using this font, regardless of the conditions or license applying to the document itself.) readonly def
/Copyright (Copyright URW Software, Copyright 1997 by URW) readonly def
/FullName (Standard Symbols L) readonly def
/FamilyName (Standard Symbols L) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0.0 def
/isFixedPitch false def
/UnderlinePosition -229 def
/UnderlineThickness 46 def
end readonly def
/FontName /StandardSymL def
/PaintType 0 def
/WMode 0 def
/FontBBox {-180 -293 1090 1010} readonly def
/FontType 1 def
/FontMatrix [0.001 0.0 0.0 0.001 0.0 0.0] readonly def
/Encoding 256 array
0 1 255 {1 index exch /.notdef put} for
dup 103 /gamma put
readonly def
currentdict end
currentfile eexec
D9D66F633B846A989B9974B0179FC6CC445BC2C03103C68570A7B354A4A280AE
6FBF7F9888E039AB60FCAF852EB4CE3AFEB979D5EA70FDE44A2AE5C8C0166C27
BF9665EEA11C7D2329C1A211DD26BB372BE5822F5EA70D99EB578C7BEFD44CDF
045A363056E5E1CC51525EA6FC061DCEBB337208EFF729802376A2801424F670
0E7E6397B28F15BC10B40012B0A3EAEB2693E8F7F627C4C9C7C6C5BFF105C1E4
1B2B9E8F09253B76040D268B80719E1B3F5A55AA4706D91AF999C9244BA4C770
FE5B3485F083B758947E4EDACBB478E55F1EDA6FD43755F3819F9292072ADAED
FDA1ABB92842199CF874FD0D8A6429D69D5F1E8BB56FA51E0B0A12874786CC3B
1C24C9C608F40C7774946DE7D3EC6F234B793C9170E9678D19994D61A213FE29
925028E208DEBAE41C0BBCBFE69FF9920D5473AF395F9D07E27F7871953BCF83
0D8E781B183FAC31DAA08488CC639C348BCCB2FDEA9BF11CFC9CF589E0E5D912
9471AF733E09424A60685F4516C1BFC2912883835D495AFD44781CE0FCE03FD1
AEFD4190D530C243E82BACF9BBB7135AA21AC329BD25AFEB5284D0FEA70F0757
7047772298ABD77E1BC00DAA5CDC0B8C239EFAD8A783A1260C2C8114B1CEF1FB
FEEAE79B4EC33824BA74E4BEA34BA26730DC2B90DDA59868D0D53327118E0A9C
CF307F710DEBD7CE9A7888FE9B339E1561B4B83F838F8D9C615054192F4B8452
5908F8BAA5220EE28F4222C1FA5A97DB983BCF9F584866482CA7EC79A4AC1199
8E071F5260F6478E070D0EB84A342890283F5B5640CF3C44AA2A1724F5F09186
1086C71F7953533AC56D6265200EAB54BBF0FEF8154EC13229A8B2AF4E6F4449
04A576D348562D512556AF95293C7D115FCAD4853FE3812D5760D304DCB7FFB3
5DC48160548740F81F1E40DA43DE1A71347A69CF188901800F4AB8020F184072
2B7A27D5844580135B61E4E0702C49079CD216A6C58ED45999C8583B1FB0BC61
C722B6A634305F08AB34397B5321DC04B524A3A442C7E50D3444F56DFF34606F
D3DF9B8E94FD2F4536D46D8675B9A149EE5DF2E86F375584E6F2906FECEF8966
5ADB994388105F793D65512AFFEBD6E4922E00C3EE943A669265B6C7195B0D27
BC596D674542D4FF953D73E7A65D4763AC5A947D9DD9643DC9D3E313BE1FA117
44BDB15B8AC24BE3A1A79217D70E58BE776F3C928EABFB5FAB890893EF6E84EB
512382A699F24A0C957B5E61D49B01B2335CF9D696E571A1A782CF26D89C45F7
E2B004DDEA102EA2A76D6CD0DE689090300A4E23435D43B9BFC81DCA45DDF859
1CBB58C0042BDAC015199669CE0DF4B59C05516AD02481D7D89AB085C9FBEEB5
81B3AB901545CBAAA5BB99BC8262CFCD4D51B2D07F2FB3D3D0BFB1743BADD3CE
BDB83135364B8E03CEF3397A18095DBFE558485735323A4AE8B39401C3BE2E5D
147E641D520FFAB6AE7FBF29
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
%%EndFont 
%%BeginFont: NimbusSanL-Regu
%!PS-AdobeFont-1.0: NimbusSanL-Regu 1.05a
%%Title: NimbusSanL-Regu
%%CreationDate: Thu Mar 20 10:08:51 2003
%%Creator: Primoz Peterlin
%%DocumentSuppliedResources: font NimbusSanL-Regu
% Copyright (URW)++,Copyright 1999 by (URW)++ Design & Development
% Generated by PfaEdit 1.0 (http://pfaedit.sf.net/)
%%EndComments
FontDirectory/NimbusSanL-Regu known{/NimbusSanL-Regu findfont dup/UniqueID known{dup
/UniqueID get 5020902 eq exch/FontType get 1 eq and}{pop false}ifelse
{save true}{false}ifelse}{false}ifelse
11 dict begin
/FontType 1 def
/FontMatrix [0.001 0 0 0.001 0 0 ]readonly def
/FontName /NimbusSanL-Regu def
/FontBBox [-174 -285 1001 953 ]readonly def
/PaintType 0 def
/FontInfo 9 dict dup begin
/version (1.05a) readonly def
/Notice (Copyright \050URW\051++,Copyright 1999 by \050URW\051++ Design & Development) readonly def
/FullName (Nimbus Sans L Regular) readonly def
/FamilyName (Nimbus Sans L) readonly def
/Weight (Regular) readonly def
/ItalicAngle 0 def
/isFixedPitch false def
/UnderlinePosition -151 def
/UnderlineThickness 50 def
end readonly def
/Encoding StandardEncoding def
currentdict end
currentfile eexec
D9D66F633B846AB284BCF8B0411B772DE5CE33C33655F6FF751F340A8D6C01E3
2E02C24E186BA91B34A1F538959D4450CB683EAE5B034D030186901B458D3777
6B3942BD2E07121385120248891AEC2EB33C4E3A0CF00828D0F130C31A918C18
979FE94379C648EF21ABF659253E43CD1253866F157F1DF85AE7E8714F061B1E
ABA3AD094FE8D6293916FA82EE4F486C7E513A06D4C9BE44306A8287970B4ABF
B6D1F9274A5A0BB6ECF713ADBD1260D5D6C4420D357FD486470A74B2F0621B59
A9373ABECDBF32FA68AABB66FAB0C970A3354A335D70DB2CC5A3208BB6D768E7
B58CD9BC2B6B7E110693C5A88D680B7290DB121996E3B7C8AE3C23147280F8BF
D8C60B415552700FF0E44C2257B467ADD5D550F61EC34A76143393E0B34D55C0
8B64B48E5F1FD16E16B967511AE15434B7F755BDF2574191E3C3DC528B69B5BA
7DDBBD3C7878FA69ADE75011A2C0F02F5707E86FA632D1269281D3C265B31F3B
F3145052467647AFE18B9D763FAEE4BA72CB9C385568EE5BBF5854C278F1E3CC
475C6234E83ED33345268BE52F0931B58F302EDA0D5751348E7B7E53D4882FB6
9343BDAAE87E48F6E82024D8EC1FACBBA36582092CCD76553B0449A5090774EA
7242123C53B80F2E927B98DF2B36C403D1FA1E9F8439F3964DC9F89A0CAB5AE2
C907309460F097AA87BD156575D6C73EDB2B40C015E67734397ED14395C43394
7A0201C6B0F652B035FD7BB82ED236D0F7C20048AFD83A56925C7A2898B46270
B440913E4714FD89697B3E59F5BDD5A2AACF6630257957ABE1A63502A3081B6E
307A534A9E238F986D4C866AFBAB7A0B1B5A6E99AA0A56DC1FD7E8A39CC45147
259AC7033A0C58192CA82FB12E09F309F75690043646193AD92D2368F345771F
01CFD21236BA52F74E36CF4B94259CDBA2EF1D61AD93A2B942A9896B0819D20C
59E440851CB99E89C887FC62FD9E7F88F54E5BC157D81A5FBC70699820C51BC6
27D7755B195C0BAD8225A6F3EAE0A5A674E8AF6B11BCC69DCF5FB89D8BE0E2E5
FE7E2588F93F583E4E2F6ED5457E90B902B02F51D54B9F0BA54291E687F4A7A2
08CA5FCE0C9F3B954247312EDA3C532D3DCDFDCB56FFE03B36DB7D549D4203C6
7DA8772A2F732A15DE675D3212C28DC755E3D0156A777BF514112ABBE4372ACB
97D7834813E1850F90CEE543B4C09BE1E93742EA98B8CACC09FCC4D2595EECD4
46C942EEA60211FA7DBC11CE869D55BF0C7EC6AA747EB2AE2CB3CC2DBEC936C9
540CE2E08291323B36F6549CDB97BBF9F0DA429CA9C863B629410885540DA6C4
9AAADB30C39051C993CB547BCD573D6448DC09BF7FF2D1B108ABEC2AAEE4060D
182ABDB3100AC627E5C883E8F42D90D699C8028D4123472F211C8FBB744D7E3D
C626ED03D8517D69E1ACD26BE4F83FAE31122294816736827D138E4F4CAB1681
236C1654E01231EA7F08AD0E73BBE1BE19A7AD6DA63AE0C7F5A360A53BB35268
CC90125C7545D9D59F5127F0AD964AA66DF020F639832FAF9C2CCA82C01120BA
6469960C350D3AF786666EC14158728E0BA2DD8A639C28E0A7EA8BBF608FD7DF
79C7B5DDEA05C8C3D6FC70177D1A9EA9AD056F0CE31AB535A22FF7EB33748071
694BCE70111394D24DCEA030AE4C07AECAC39144621A6B719682FF74DB5C081C
B538F17221F8D06EAAD43B64DA5CF93030CB93DD54FCC5B44980F2AC6A66C512
54F71283450DFCA305E0B134FC95E54C2699C18624EBE6A7D0067E306EADCFE5
2D2A78AA02574548893EE05FFD60CB41E00B2E7761AA55732EFE6EE3C19EEF6B
179276229BA324E59A81107FFFAE0685C7C24E70ACB8564454277C41C28075AC
96964C61BD933742996058691C47B09CEBE352FC29A63119C731B3FC8D78A9E3
69F922CA6454BC1F6CFD1E03B285AFC3D8A7C81B83F0D950DAD2F3E562353B9A
1D56DABD05371F9479BFA4CAEC5CBAAC37C200F6E27BB35E591601EBFF9580F3
78E3BF2E599FF22A1434E7D661083C7F8D02F91CCD580EA19FC752DC79692238
0B10F1F30E98E1E0ED657429F1381D1B03331A3CC98E1AF521B1414EE94D14C8
7D708250798164F82B27010F365EFE7343AD67273FF8D268877C3A3B197F3380
C2E498998FD037D939B772D6975B5830259A7146206F25481C94C0C99771491E
1E13819CF6A733333529F06FDFCA1636023C3B45D99837E560B8513E93E598BA
51322F0548A74AC221796FEF28187ADA9EF618EFF432ABF3634C8ABE96901D4D
C836B1FFF64714BCB334503F9F4AD87247E41367FC2CEC2A5A0598DF345C143E
B8F2A289EA703C24663DD7C2033896ED769E545928DDD1FBC289A18A4B9627E8
33A471EB8D00A96016F8478482FD47A8B1F96657CE2E7073A34CB3ACD7856ECE
4D6569FFCA7C6759B8D7B292A35EE0B7A1799824930A7A47150A32FF68165987
72E12C1A699122AE3F47864DE0CBA343AD15C3221EB12B68F6BD8FD594BF422A
E4E21484D058C1C336B45F181170E1A00DD76C862BD258885BE16FF4892A27DF
2CF37BF7EB9599012F285E95590E4999A373A0AE79D20C1CE169A334633DDE9B
DD94208B7A2A09474FB1AFD2BF764A7D35DA22E3FC943AA32D2E5C8BC22EFCE8
582B4C98AA440496FADB48971A12DFA2F07B91A6DD9750A529766FE954E0D7B3
A8D29BA24B4F1531A992ED22292AE21E8ED2EF964E546E5309001E8E94F4336D
40A60E3EB299AA03D6F05AAA23E449AC509C381D8052C8F9160296989F75914F
E2CE1319E382F752A33C2377D779DA1F0DE6FC09910A13B23860D75CE196874E
CEC5C8683B558AFED820387436E05EE2FBCA8A22EF35DBEE9CAC2011C7A9BD05
B12592AC0E9ACB521CEAEDCF8266D724C7E502B3C0BFC0DA27257C0AE55D5311
9CC5276FF2E93EF7BCE9F7840AC69BABCA785F56E731B66355C471B7C299B3FC
5ED34E8A3C6A6E1FEE1756481D50EC6C75884F314104BC8AFC8F8955612428B1
E8E5345A8E50D790A83FCA21578C30323C2DE134127B297C46A8BDCDC78B9519
E27CCCF06BAF267D84EC6218537829465238F718E129C80C2C47A9C688FC7FB9
D345698FB15781040D75C27CD4F8DC3CEF32B04ED6ACDB08469A16630E5EDD17
CF4BFDF55810201D20A13E3D9672DAB3BD8BEB0EC888078B22E238F24B0CDC01
E06788602A10D3AD5327DEAA6F449634202DE92C9F209F6780425A73B87C2DCC
A03DD6C019372558A9170F342E7C6405EB2663F48DE933591D65DB15D35383D5
C0793FB631F9733E2AC315C5E3523F1CF2EACC7283318C95BD0E5BD1BEDBA387
2ECE39B1384D5D044EAAD1A1E7162EC40DB5AF077E78356BDF8CB3C4172ADC41
8749090F6202DFC9BF81E72509B4309FC21A9DB1E109911F08858641677AC254
48896A4DEEE70B2EC5F19CDFE6640EC207E7FE6F6B7BA2D603E631EF52D2431D
CB90D6F05BF5EE102ABD968E70ED799DD0F863F3E9E5552A02DB408D10402F70
FBE3E29AFDB7F48E7229B9DDC90D73C32DBB61E5FE8BD96F29E262D83C486EF3
B020CACD3AC02891AD374E3EA9B0CBED90924516A2F08ACEF3A57C5B97CEC165
A9B9AD83323FF5E0064234C4FE80E00062ACA59F8B5FBE94624629CF829C1A50
7056E662625F08564EF70419735EDEC2317F7D12134272F5DC53B239FADB6527
F712B9495C8D49A69525C3A14335054666DCD8662DDE4FB4C9D33CF42D052EC4
EACBD12767A091399E1863317F30E078E2351D968B32BB88F4C2B0AFBC3F4FDD
9AE4B08DA8902BB9437996E66BBC364B743BCC191F1F787011A5A68F17B533BF
490C8E7748BAC5F5588FAA5E6DA65784572367E08F00788738257FC366A51C6C
B82BFAB5CA83C9CF9D07F0762F4973742ACA25C0B6510F64E83C886E9FDD94A7
5FC232B7FB455A7E3ABB6CA186F3A46B0EE5944BDA71E9D4CDEDD609E6F38F3A
F09B1F70518F1D49039D652EF838D0E37231AB270B9DDB09D4EC307C3866EB33
A19CDEF11AF70773441181DE5F872D0A9D770A2F0C1830B8586D5F8D11B7F60F
F94A4E384933AB7E2EB32653DADA6002C3DBC034F24D49E2170E0A7D09988283
E35CA913888D814EF90D44CC26D350011A2841C47DFB7E98E82ED7B10123724A
C47DC9F0653AF61CAEE3419F1F80A56D8EC590D51CBD704C441FFB711B17AC31
7A4C46E37D531E95B104C07B4EA682AB6178956B1D68E58CE837915AD3198216
F053D8AC374C4F2B9F5CAAD55E8DE25579C3EA5F20B1840E9049B9567D17916E
FF7C2646FB9660EFD76294A2D3917647089CD98719D415EEDE161382C84A0E41
CEC77300FF8D2EF546B473C508C2EB62B0FB35F8BB5028F28EE28B1A6B3996A2
098C254D9F8F5F45D81C2FD6E4F9414A5F28E3AF52237634FA85BF456A112B2E
A3A90CCD311D938F3D1B19D9758B18D88452468BEBDFA699D22BF908B5E8AE1F
AA4439861C92D3E36806E5190C16F36D649E28F734622442F05A60646E7EE107
C1A6B340BA57EAFACE43471439ADE103922C866A19141D2D1615C63617DBA193
7F3F0C17935365ACA2284633DE612AB2346BE884D3384C9F162FDBC2ABFA0457
39772A6ACD9768C425AE2A1D5226B8E403F8C94C91E40A62C9EE357893371F47
F9F7D547727485E9EAE8A1776E098E1A7011A5775B6F7CCDFCA2BA6416333FE3
47CC576930C08F84EFD195695E1D3463D1257D6D482D9E1C1228D2C058843D74
C8D4537C812B22D6E59C7D58A496C070169989C889069AD4FCBE152629294500
CDDF45E481AD22F45FC29E694D52CB7C523B550B99F2FEF21B72C14775F04EEC
CAF78A75100F1006242ED97D2BCC74A91043D0E5AC429F492181AFE2CBBD6371
8ECE9D4FE798C3E102AC83F5996010EB297A88B168192B8435944634C73F0241
D453EAFFC4B922E818D5DE51FDBAAF4F0CAFB8138EE8A9396A0D94B0C88CC555
963E85758C696DA22EDBE9897CDB4BF592376E294380323BF87F8B5C52BD19E0
7AA79113DFA340D67CD04FA3304D66DC5A319F9F99FD1C28551425DE111401E5
3509274620CB2F288D123DBB8F9E6A2DC50D5EF3F3A88CF82835CA5FD83BA324
657153EE00FA6E845D9609F9245451DEC8087A3836F7BCD50296D498EE66906F
02EEE974FEABD2060DEAE5673818BC7133DC0B6C787EEE382799F6B9FDCBBC62
53C222F9A212330FF5FFBA2DD75E8A631FF161DCBB9BCDFAB90DBB2375E55521
FA435822E3AE763C182E13564FF7C950D81726632AFE034D3D5BC57CA4C444CC
DF69CA8EF4535E4586639FB0D1FC646B2F1E5EE527D2540A0EB5992B77731A2A
27A865188497A670FB24F3C49E260B75FC62C2CDF9C2FDB5F5B33703BA648811
DA0E11599A3BF4395FD337F5D4CB707ABCE801F778C14D846D673D80A86A9DFC
76B52CA90E6F2B3838B307E977BFE6709639813F47887E738DC639181FC0AA9B
2D0E2F13060BE986CD76BEDA7416F123987382DBAC3944E3947CBC1869F8703F
5F7622332B
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
0000000000000000000000000000000000000000000000000000000000000000
cleartomark
{restore}if
%%EndFont 
TeXDict begin 13090570 6578176 1000 600 600 (swan1.dvi)
@start /Fa 152[34 103[{ .167 SlantFont }1 83.022 /StandardSymL
rf /Fb 141[28 3[46 69 3[18 3[46 1[42 46 46 18[60 69 8[60
2[55 7[46 5[46 46 3[23 46[{ TeXBase1Encoding ReEncodeFont }16
83.022 /NimbusSanL-Regu rf end
%%EndProlog
%%BeginSetup
%%Feature: *Resolution 600dpi
TeXDict begin
% dvips-unknown
statusdict /setpageparams known { hsize vsize 0 1 statusdict begin {
setpageparams } stopped end } { true } ifelse { statusdict /setpage known
{ hsize vsize 1 statusdict begin { setpage } stopped pop end } if } if
 end
%%EndSetup
%%Page: 1 1
TeXDict begin 1 0 bop 0 TeXcolorgray Black -600 -600
a
 /pssetRGBcolor /setrgbcolor load def /pssetCMYKcolor /setcmykcolor
load def /pssetGraycolor /setgray load def
 -600 -600 a -600 -600 a
tx@Dict begin  gsave STV CP T /ps@rot 0 def grestore  end
 -600 -600 a -600 -600 a
tx@Dict begin  gsave STV CP T /ps@refangle 0.  def grestore  end
 -600
-600 a 0 TeXcolorgray -600 233 a
 tx@Dict begin /mtrxc CM def CP CP T STV newpath /ArrowA { moveto }
def /ArrowB { } def  0.8 SLW 0  setgray   0. true 0.0 0.0 199.74625
100.375 .5 Frame  clip newpath mtrxc setmatrix moveto 0 setgray end
 -600 233 a @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.0 SLW 1 1 1  setrgbcolor   0. true -1.00374 -1.00374 200.75 101.37874
.5 Frame  gsave 1 1 1  setrgbcolor  1. .setopacityalpha  fill  grestore
end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  /ArrowA { moveto } def /ArrowB
{ } def  [ 2.70303 31.66809 30.729 26.51814 70.39206 22.27863 110.25438
21.4533 150.05981 24.12813 189.46672 30.2167 197.832 31.98067   1.
0.1 0.  /c ED /b ED /a ED false OpenCurve  gsave 0.71114 SLW 0.5 0.5
0.5  setrgbcolor  1. .setopacityalpha   0  setlinejoin 0  setlinecap
stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  /ArrowA { moveto } def /ArrowB
{ } def  [ 29.16388 99.3571 31.98067 98.81657 71.53041 93.55246 111.4496
92.67068 151.19774 96.14175 170.88707 99.52773   1. 0.1 0.  /c ED /b
ED /a ED false OpenCurve  gsave 0.71114 SLW 0.5 0.5 0.5  setrgbcolor
 1. .setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore
end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  /ArrowA { moveto } def /ArrowB
{ } def  [ 174.92732 98.75926 175.46828 96.2555 182.80896 61.3725 189.72287
26.37575 194.41737 1.33719   1. 0.1 0.  /c ED /b ED /a ED false OpenCurve
 gsave 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  /ArrowA { moveto } def /ArrowB
{ } def  [ 106.32788 98.53177 106.52716 88.43117 107.21008 53.03586
107.8357 17.61234 108.09186 2.44688   1. 0.1 0.  /c ED /b ED /a ED
false OpenCurve  gsave 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  /ArrowA { moveto } def /ArrowB
{ } def  [ 38.2121 98.64552 37.3299 93.63799 31.3264 58.58435 25.69281
23.4452 22.22176 0.85355   1. 0.1 0.  /c ED /b ED /a ED false OpenCurve
 gsave 0.71114 SLW 0.5 0.5 0.5  setrgbcolor  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB
{ BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0
0 moveto  EndArrow  } def  0.99594 SLW 0.8 0.8 0.8  setrgbcolor  /ArrowA
{ BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0
0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1.  1.  scale
1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def
 [ 14.96616 4.52388 19.91682 3.64212 25.63594 2.70303   1. 0.1 0. 
/c ED /b ED /a ED false OpenCurve  gsave 0.99594 SLW 0.8 0.8 0.8  setrgbcolor
 1. .setopacityalpha   0  setlinecap [  5.0  3.0  0.0  0.0 ] -2 -1
add  DashLine  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.99594 SLW 0 0 0  setrgbcolor   0.99594
SLW 0 0 0  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB
{ BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0
0 moveto  EndArrow  } def  [ 34.34247 57.3609 33.46027 52.09679 32.32236
45.04047 31.15578 37.98459 30.01743 30.92828 28.90816 23.87198 27.79846
16.81566 26.71698 9.75935 25.63594 2.70303   1. 0.1 0.  /c ED /b ED
/a ED false OpenCurve   0.99594 SLW 0 0 0  setrgbcolor  /ArrowA { BeginArrow
1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto
0 0.1 L stroke 0 0 moveto  EndArrow  } def  [ 31.81006 57.8159 34.34247
57.3609    /Lineto /lineto load def 0  setlinejoin false Line   0.99594
SLW 0 0 0  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB
{ BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0
0 moveto  EndArrow  } def  [ 32.12308 59.55165 31.81006 57.8159   
/Lineto /lineto load def 0  setlinejoin false Line   0.99594 SLW 0
0 0  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0
0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB
{ BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0
0 moveto  EndArrow  } def  [ 27.71294 60.34833 32.12308 59.55165  
 /Lineto /lineto load def 0  setlinejoin false Line   0.99594 SLW 0
0 0  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0
0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  moveto } def /ArrowB
{ BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0
0 moveto  EndArrow  } def  [ 34.39935 95.48747 33.0335 88.45938 31.66809
81.43173 30.33046 74.40407 29.02191 67.37598 27.71294 60.34833   1.
0.1 0.  /c ED /b ED /a ED false OpenCurve   0.99594 SLW 0 0 0  setrgbcolor
 /ArrowA { BeginArrow 1.  1.  scale 1 setlinecap 0 0 moveto 0 0.1 L
stroke 0 0 moveto  EndArrow  moveto } def /ArrowB { BeginArrow 1. 
1.  scale 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 } def  [ 25.63594 2.70303 26.34709 2.5893 32.03798 1.70709 37.75667
0.91042   1. 0.1 0.  /c ED /b ED /a ED false OpenCurve  gsave 0.99594
SLW 0 0 0  setrgbcolor  1. .setopacityalpha   0  setlinecap [  5.0
 3.0  0.0  0.0 ] 2  DashLine  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.5123 SLW 0 0 0  setrgbcolor   158.02655 14.25502 2.845 .5 CLW mul
sub 0 360 arc closepath  gsave 0.5123 SLW 0 0 0  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.5123 SLW 0 0 0  setrgbcolor   108.66103 53.57639 6.48712 .5 CLW
mul sub 0 360 arc closepath  gsave 0.5123 SLW 0 0 0  setrgbcolor  1.
.setopacityalpha   0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { moveto } def /ArrowB { } def
 0.5123 SLW 0 0 0  setrgbcolor   68.96933 82.48456 2.845 .5 CLW mul
sub 0 360 arc closepath  gsave 0.5123 SLW 0 0 0  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   130.31361
60.06352 2.992   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   158.85144
27.03001 2.528   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   100.95044
49.28 1.512   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   87.26459
7.59683 1.512   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   163.14784
74.4323 1.448   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   111.39229
29.78993 1.301   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   159.81918
80.94809 1.259   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   83.87863
17.29932 0.954   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   98.87344
75.74127 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   107.0108
74.91594 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   115.80287
52.86523 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   167.01746
12.12071 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   163.46086
75.0297 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   120.61113
65.38452 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   179.9635
5.49118 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   196.69365
20.6284 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   141.52391
87.37834 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   172.79344
4.0971 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   83.65112
49.70677 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   119.9282
50.70271 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   193.05196
9.33258 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   98.30428
12.43375 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   165.90776
28.76576 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   185.28407
0.11374 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   105.5312
65.15659 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   126.61461
95.91426 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   139.84503
89.11409 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   192.16975
33.46027 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   115.48984
58.49883 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   109.31529
53.26335 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   121.29405
77.64764 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   153.87256
66.20941 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   167.04611
4.66629 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   108.09186
95.85738 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   188.55629
81.57413 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   153.0759
13.25906 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   131.5084
34.71237 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   111.81906
74.28989 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   144.65373
90.84941 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   83.99237
89.31337 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   138.67847
70.8757 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   110.39677
97.82063 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   80.8912
9.16196 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   163.94452
31.15578 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   110.70981
86.92291 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   159.19313
7.0563 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   186.87741
87.86198 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   161.58315
65.78264 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   181.69926
70.84747 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   157.48604
32.37923 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   133.04488
47.25987 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   111.4496
56.53558 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   198.57181
4.63763 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   135.29292
26.85939 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   103.65349
11.8077 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   192.34038
89.00035 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   166.87549
50.70271 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   82.25706
29.07878 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   109.48636
35.2529 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   172.0823
86.83781 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   149.40555
2.07698 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   84.70395
40.68721 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   183.97552
18.06732 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   104.13713
55.45453 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   155.46591
46.20705 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   139.50378
11.1252 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   191.11693
9.3608 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   188.75557
84.19165 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   162.32295
21.33955 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   168.55392
18.57964 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   162.74973
45.32527 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   186.05252
86.75229 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   123.2573
68.51433 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   156.63248
98.64552 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   193.50696
17.18556 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   102.34451
70.16455 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   119.21706
69.19727 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   102.43004
32.91975 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   102.51514
94.97517 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   158.31093
33.23277 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   122.80186
61.68552 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   144.02768
65.98192 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   188.55629
46.57695 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   85.785
37.55782 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   173.647
2.78856 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   157.31541
70.5058 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   94.1785
76.08252 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   88.14679
78.21638 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   103.53973
62.96584 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   169.80603
5.46295 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   142.23506
35.99269 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   155.46591
73.94864 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   134.0977
16.07587 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   165.05421
5.34921 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   132.6181
62.99449 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   142.46298
46.17883 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   94.63393
60.51895 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   116.05858
38.78127 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   115.26192
26.60324 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   167.47289
41.56941 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   163.83076
81.77298 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   64.78668
62.59595 1.216   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   1.6502
15.39294 1.087   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   52.35294
90.59369 0.954   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   0.71114
89.11409 0.748   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   7.25558
28.62335 0.457   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   8.621 78.44432
0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   59.55165
12.60437 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   57.70215
26.20512 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   55.39766
46.91862 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   24.52625
63.90492 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   70.93257
68.91246 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   69.25414
1.76396 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   75.14388
84.98833 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   49.99158
32.2937 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   15.56355
68.82736 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   62.11229
61.2874 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   27.91222
60.66135 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   76.02563
69.79466 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   47.3454
12.00697 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   81.03362
88.60179 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   50.87334
31.63943 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   10.7553
51.61314 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   68.74184
93.60933 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   57.38913
92.04463 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   51.75554
29.59065 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   22.27863
69.65225 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   40.63034
15.42159 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   27.7416
75.9119 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   37.8704
22.16487 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   54.82849
64.844 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   24.64 65.61201
0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   59.86467
56.64932 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   65.8113
64.38857 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   29.05013
86.49614 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   79.21233
24.24187 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   0.31302
47.51602 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   28.45274
98.0199 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   39.83366
87.7769 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   24.89615
64.55919 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   39.37866
0.71114 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   74.37541
3.15804 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   41.25638
33.3183 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   47.37363
46.29257 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   74.97281
3.52792 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   77.61899
88.31741 0.427   1. .setopacityalpha  SD  end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath 0.5123 SLW 0 0 0  setrgbcolor   76.25314
12.20624 0.427   1. .setopacityalpha  SD  end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  0.99594 SLW
0.7 0.7 0.7  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  [ 156.60384
23.4452 129.8013 -19.29077    /Lineto /lineto load def 0  setlinejoin
false Line  gsave 0.99594 SLW 0.7 0.7 0.7  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  0.99594 SLW
0.7 0.7 0.7  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  [ 199.0268 69.16861
161.78242 30.07474    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 0.99594 SLW 0.7 0.7 0.7  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  0.99594 SLW
0.7 0.7 0.7  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  [ 156.09152
30.2167 133.38655 56.50693    /Lineto /lineto load def 0  setlinejoin
false Line  gsave 0.99594 SLW 0.7 0.7 0.7  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
@beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  0.99594 SLW
0.7 0.7 0.7  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  [ 199.3967 -2.44688
162.2943 24.52625    /Lineto /lineto load def 0  setlinejoin false
Line  gsave 0.99594 SLW 0.7 0.7 0.7  setrgbcolor  1. .setopacityalpha
  0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial
@setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  0.99594 SLW
0.7 0.7 0.7  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  [ 2.27626 90.9918
8.59277 98.58864    /Lineto /lineto load def 0  setlinejoin false Line
 gsave 0.99594 SLW 0.7 0.7 0.7  setrgbcolor  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial @beginspecial @setspecial
  tx@Dict begin STP newpath /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  0.99594 SLW
0.7 0.7 0.7  setrgbcolor  /ArrowA { BeginArrow 1.  1.  scale 0 CLW
2 div T 1 setlinecap 0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow
 moveto } def /ArrowB { BeginArrow 1.  1.  scale 0 CLW 2 div T 1 setlinecap
0 0 moveto 0 0.1 L stroke 0 0 moveto  EndArrow  } def  [ 7.34067 80.15141
2.16252 87.1222    /Lineto /lineto load def 0  setlinejoin false Line
 gsave 0.99594 SLW 0.7 0.7 0.7  setrgbcolor  1. .setopacityalpha  
0  setlinejoin 0  setlinecap stroke  grestore end
 
@endspecial
0 0 0 TeXcolorrgb 624 213 a Fb(M)14 b(29)p 0 0 0 TeXcolorrgb
-1 -83 a(N.)23 b(Amer)q(ica)h(Neb)m(.)p 0 0 0 TeXcolorrgb
-230 -365 a(M)14 b(39)p 0 0 0 TeXcolorrgb 521 -236 a(Deneb)p
0 0 0 TeXcolorrgb 643 20 a Fa(g)-600 233 y
currentpoint initclip moveto
 -600 233 a
0 0 0 TeXcolorrgb 0 0 0 TeXcolorrgb 0 0 0 TeXcolorrgb
0 0 0 TeXcolorrgb 0 TeXcolorgray 0 TeXcolorgray 0 TeXcolorgray
eop end
%%Trailer

userdict /end-hook known{end-hook}if
%%EOF
